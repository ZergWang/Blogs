题目链接：https://www.luogu.com.cn/problem/P2242

公路上有n（n<=15000）个坑需要维修，因此要封住m段公路。给出坑的坐标，问在不漏掉任何一个坑的情况下，最少要封多少米的路。
比如说有5个坑的坐标：1 2 5 6 8 9，要封3段路，那么最优解就是封1\~2、5\~6、8~9 ，最少封了6个单位长的路。

一开始我从Dp的角度思考，也有了思路，我的状态转移方程是这样的： f[k][i]=min(f[k-1][i]+s[j],f[k-1][i])

(f[k][i]表示在封k段公路且覆盖第1个坑到第i个坑的时候的最少的封路的长度，s[i]表示这k段公路在k-1段公路的基础上又多出一段后减少的封路值，当我们决策到i时有两个选择，那就是：1.第i个坑与之前的所有坑连在一起为一段，2.自己一个坑一段。我们需要比较找出最小值就可以了)
Dp虽然好，时间复杂度为O（n^2），题目给出的n最大为15000，这样用DP反而会超时。而用贪心就能得到正解。
还是这5个坑：1  2  5  6  8  9

Data[i+1]-data[i]，得: 1  3  1  1  2  1
将新数组排序，得3  2  1  1  1
9-1+1-(3-1)-(2-1)=6
9-1+1是求出从第一个坑封到最后一个坑要封掉的路的长度。
而（3-1）和（2-1）就是说明在两个地方断开后能减少的最大封路的长度。
为什么这样做？因为题目要求最少得封路长度，而将几个坑连在一起封就会导致一些没有坑的公路被封掉。这样我们求出两个坑i,j之间的距离x，就能知道如果把i,j连在一起封就会多封x个单位长度的路，我们将计算出的新值排序，就能知道在哪里断开能最大地减少封路的长度，再减去即可得到解。
```cpp
#include <fstream>
#include <algorithm> 
using namespace std;
ifstream fin("公路维修.in");
ofstream fout("公路维修.out");
 

int a[15000],data[15000],n,m,ans;
bool f[15000];
void init();
void work();
bool cmp(int x,int y);
int main()

{
  init();
  sort(data+1,data+n-1,cmp);   //快排
  work();   
}

 

bool cmp(int x,int y)     //确定排序是升序还是降序
{
  return x>y;
}

void init()
{
  fin>>n>>m;
  for (int i=1;i<=n;++i) fin>>a[i];
  for (int i=1;i<n;++i) data[i]=a[i+1]-a[i]-1;  //生成新数组
  ans=a[n]-a[1]+1;  
}

 

void work() {
   for (int i=1;i<m;++i)
    {
      ans-=data[i]; //因为输入数据要求分成m段就可以了，那我们就需要截m-1次
    }
   fout<<ans<<endl;
}
```