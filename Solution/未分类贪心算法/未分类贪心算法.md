# 洛谷 P2242

题目链接：https://www.luogu.com.cn/problem/P2242

公路上有n（n<=15000）个坑需要维修，因此要封住m段公路。给出坑的坐标，问在不漏掉任何一个坑的情况下，最少要封多少米的路。
比如说有5个坑的坐标：1 2 5 6 8 9，要封3段路，那么最优解就是封1\~2、5\~6、8~9 ，最少封了6个单位长的路。

一开始我从Dp的角度思考，也有了思路，我的状态转移方程是这样的： f[k][i]=min(f[k-1][i]+s[j],f[k-1][i])

(f[k][i]表示在封k段公路且覆盖第1个坑到第i个坑的时候的最少的封路的长度，s[i]表示这k段公路在k-1段公路的基础上又多出一段后减少的封路值，当我们决策到i时有两个选择，那就是：1.第i个坑与之前的所有坑连在一起为一段，2.自己一个坑一段。我们需要比较找出最小值就可以了)
Dp虽然好，时间复杂度为O（n^2），题目给出的n最大为15000，这样用DP反而会超时。而用贪心就能得到正解。
还是这5个坑：1  2  5  6  8  9

Data[i+1]-data[i]，得: 1  3  1  1  2  1
将新数组排序，得3  2  1  1  1
9-1+1-(3-1)-(2-1)=6
9-1+1是求出从第一个坑封到最后一个坑要封掉的路的长度。
而（3-1）和（2-1）就是说明在两个地方断开后能减少的最大封路的长度。
为什么这样做？因为题目要求最少得封路长度，而将几个坑连在一起封就会导致一些没有坑的公路被封掉。这样我们求出两个坑i,j之间的距离x，就能知道如果把i,j连在一起封就会多封x个单位长度的路，我们将计算出的新值排序，就能知道在哪里断开能最大地减少封路的长度，再减去即可得到解。
```cpp
#include <fstream>
#include <algorithm> 
using namespace std;
ifstream fin("公路维修.in");
ofstream fout("公路维修.out");
 

int a[15000],data[15000],n,m,ans;
bool f[15000];
void init();
void work();
bool cmp(int x,int y);
int main()

{
  init();
  sort(data+1,data+n-1,cmp);   //快排
  work();   
}

 

bool cmp(int x,int y)     //确定排序是升序还是降序
{
  return x>y;
}

void init()
{
  fin>>n>>m;
  for (int i=1;i<=n;++i) fin>>a[i];
  for (int i=1;i<n;++i) data[i]=a[i+1]-a[i]-1;  //生成新数组
  ans=a[n]-a[1]+1;  
} 

void work() {
   for (int i=1;i<m;++i)
    {
      ans-=data[i]; //因为输入数据要求分成m段就可以了，那我们就需要截m-1次
    }
   fout<<ans<<endl;
}
```
<br/><br/>


# LeetCode 11
题目链接：https://leetcode.com/problems/container-with-most-water/

```cpp
int maxArea(int* a, int n){
    int ans = 0, i = 0, j = n-1, h;
    while (i < j) {
        h = a[i] > a[j] ? a[j] : a[i];
        ans = h*(j-i) > ans ? h*(j-i) : ans;
        while (i < j && a[i] <= h) 
            i++;
        while (i < j && a[j] <= h) 
            j--;
    }
    return ans;
}
```
<br/><br/>


# LeetCode 121
题目链接：https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

```cpp
int maxProfit(int* a, int n){
    int f[n];
    int max = 0, ans = 0;
    for (int i=n-1; i>=0; i--) {
        if (a[i]>max)
            max = a[i];
        f[i] = max;
    }
    
    for (int i=0; i<n-1; i++) 
        ans = f[i+1]-a[i] > ans ? f[i+1]-a[i] : ans;
    
    return ans;
}
```

更好的思路
```cpp
int maxProfit(int* a, int n){
    int min = a[0], ans = 0;
    for(int i=1; i<n; i++)
        if(a[i]>min)            
            ans = a[i]-min > ans ? a[i]-min : ans;
        else
            min = a[i];

    return ans;
}
```
<br/><br/>

# LeetCode 739
题目链接：https://leetcode.com/problems/daily-temperatures/

本人思路：
```cpp
int* dailyTemperatures(int* a, int n, int* returnSize){
    *returnSize = n;
    int* ans = (int*)malloc(n*sizeof(int));
    ans[n-1] = 0;
    
    for (int i=n-2; i>=0; i--) {
        int j = i+1;
        while (a[j]<=a[i] && ans[j]!=0)
            j = j + ans[j];
        if (a[j]>a[i])
            ans[i] = j-i;
        else 
            ans[i] = 0;
    }
            
    return ans;
}
```

更好的思路：
```cpp

```
<br/><br/>

# LeetCode 910
题目链接：https://leetcode.com/problems/smallest-range-ii/

```cpp
int Cmp(const void * a, const void * b) {
    return *(int*)a - *(int*)b;
}

int smallestRangeII(int* a, int n, int k){
    qsort(a, n, sizeof(a[0]), Cmp);
    int ans = a[n-1] - a[0];
    for (int i=0; i<n-1; i++) {
        int min = a[0]+k < a[i+1]-k ? a[0]+k : a[i+1]-k;
        int max = a[i]+k > a[n-1]-k ? a[i]+k : a[n-1]-k;
        ans = max-min < ans ? max-min : ans;
    }
    return ans;
}
```
<br/><br/>

# LeetCode 621
题目链接：https://leetcode.com/problems/task-scheduler/

```cpp
int Cmp(const void * a, const void * b) {
    return *(int*)a - *(int*)b;
}


int leastInterval(char* tasks, int tasksSize, int n){
    int a[26];
    memset(a, 0, sizeof(a));
    for (int i=0; i<tasksSize; i++) 
        a[tasks[i]-'A']++;
    
        
    qsort(a, 26, sizeof(a[0]), Cmp);
    int now = 24;
    while (now>=0 && a[now]==a[25])
        now--;
    
    int ans = (a[25]-1)*(n+1)+25-now;
    return ans > tasksSize ? ans : tasksSize;
}
```