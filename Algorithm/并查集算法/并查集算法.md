# 引入
并查集（disjoint-set data structure，或union–find data structure）是一种树型数据结构，用于处理互相不相交的集合中元素的查询与合并。

举个例子，现在有n个相互独立的点和m条线，首先读入n和m，接下来m行每行读入x,y，代表点x与点y相连。这些点通过线相互连接，可能构成一张或多张图，最后问共构成几张互不连通的无向图或者任意两节点是否连通。

样例读入：

- 5    3

- 1    3

- 3    2 

- 4    5

由样例读入可得，1、2、3构成一张图，4、5构成一张图，共有2张互不连通的无向图。

初步的思路是利用数组来完成计算：当x、y连通时，将f[x]、f[y]均赋值为y（或x）。最后遍历数组，有多少个不同的值代表了有多少个互不连通的无向图。
<br/><br/>

# 并查集
当然，上述的算法效率太低。以上面的输入为例。假设f[1]、f[2]、f[3]均赋值为3，f[4]、f[5]均赋值为5，此时若有新的一组输入为2 4，那可能需要把数组中所有值为3的元素再度更新为5，每次合并新节点到树中的时间复杂度为$O(n)$。

本质上来说，并查集算法就是一个构建树的过程。f[x] = y其实就是将y作为x的父节点。以上面的输入为例，f[1]、f[2]、f[3]均赋值为3，即构建了一棵根节点为3，叶节点为1和2的树。同理f[4]、f[5]均赋值为5构建了一棵根节点为5，叶节点为4的树。此时对于新的一组输入 2 4，其实只需要f[3]赋值为5即可：

![](并查集算法_1.png)

图片上部展示的是原有的较为低效的处理方法，下部展示的是并查集处理方法。

因此，对于新的一组输入，可以对相关节点进行递归来找到其根节点，然后将另一节点合并到根节点上。而对于任意两节点是否连通的查询，则可通过递归找二者的根节点，并判断二者根节点是否一致来判断。
<br/><br/>

# 优化
#### 路径压缩
再来看这样一组输入：
- 5 4
- 1 2
- 1 3
- 1 4
- 1 5

按照上述算法，会得到这样一棵树：

![](并查集算法_2.png)

按照前文所述的优化算法可高效合并节点，但此法构造出的树深度过大，查询两个节点是否连通时效率过低。
实际上，在递归找根节点的同时中，将沿途的所有节点都指向根节点：
```cpp
int FindRoot(int x) {
    if (x == f[x]) 
        return x;
    return f[x] = FindRoot(f[x]);
}
```
按此方法构造出的树深度更低，查询效率大大提高。

#### 按秩合并 

简单来说，就是在合并节点时进行判断，是将小树合并到大树里，还是将大树合并到小树里。举个例子，现在要合并以7为根的树和单个节点8，那么是将7为根的树合并到8里面呢？还是将8合并到7为根的树中呢？

![](并查集算法_3.jpg)

显然，前者将整个树的深度加大了，影响了所有节点的查询效率。

对此，按秩合并的思路，就是在合并节点时对两节点进行判断，将秩小的树合并到秩大的树中。

对于“树的秩”或者“树的大小”的定义，网上的教程并不统一。若以树的深度为判断依据，则按秩合并的优化方法不可和路径压缩一同使用。这是因为在寻找待合并节点的根节点过程中会通过本次递归的次数或者之前递归时的记录来判断树的深度，但在递归的过程中，路径压缩会改变树的深度，从而导致得到的结果不准确。

因此，可以考虑使用树的节点个数来判断树的大小。对于以R为根的树，可另开数组a，a[R]存储以R为根树中节点数量。在合并时通过数组a判断树大小并对a相应元素加和即可。
<br/><br/>

# 相关题目
#### LeetCode 547
共有n个点，编号0到n-1。并给出二维数组isConnected，isConnected[i][j]如果为1表示点i和j相连，问互不连通的无向图个数。

做法：以树的节点数作为判断树大小的依据进行合并，同时进行路径压缩。

```cpp
int FindRoot(int* f, int x) {
    return (x == f[x] ? x : (f[x] = FindRoot(f, f[x])));
}

int findCircleNum(int** isConnected, int n, int* isConnectedColSize){
    int ans[n], f[n], num[n];//num[i]存储节点i所在树的节点数量
    int answer = 0;
    for (int i=0; i<n; i++) {
        f[i] = i;
        num[i] = 1;
        ans[i] = 0;
    }
    
    for (int i=0; i<n; i++)
        for (int j=0; j<i; j++) 
            if (isConnected[i][j]) {
                int r1 = FindRoot(f, i);
                int r2 = FindRoot(f, j);
                if (r1 != r2) 
                    if (num[r1] > num[r2]) {
                        num[r1] += num[r2];
                        f[r2] = r1; 
                    }
                    else {
                        num[r2] += num[r1];
                        f[r1] = r2; 
                    }
                           
            }

    for (int i=0; i<n; i++) {
        int t = FindRoot(f, f[i]);
        if (!ans[t]) {
            answer++;
            ans[t] = 1;
        }
    }
    
    return answer;
}
```
<br/><br/>


# 参考资料及部分图片出处
[算法学习笔记(1) : 并查集](https://zhuanlan.zhihu.com/p/93647900)
