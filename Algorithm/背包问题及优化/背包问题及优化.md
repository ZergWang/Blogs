# 石子分组与多重背包优化
    
有n个石子，问如何将他们分组，使他们可以表示1到n的任何数（比如说分成三组，这三组分别为1，2，3，那么我们可以表示的数为1、2、3、1+3、2+3、1+2+3即1、2、3、4、5、6），现在要使分的组最少。
类似的题型以前也接触过，所以也不算难。

首先我们分析一下，要表示1，则必须要分出只有一个石块的一组，而要表示2则又要分出只有两个石块的一组，这时我们可以表示1、2、3了，那么接下来要表示4的话需不需要分出三个石子为一组呢？如果这样做，我们可以表示1、2、3、4、6，但5就无法表示了，所以这样做是行不通的，如果分出四个石子为一组的话就可以表示1、2、3、4、5、6、7，我们继续推理下去，就可以发现分组的石子数量为1、2、4、8、16、32……

但为什么这种分组的方法可以表示1到n的任何数？我们可以先将这些数用二进制表示：1、10、100、1000、10000……这样对于10000这个数我们可以通过前面的数来决定它后面的四位是零还是一，对于1000、100、10都是一样，这样我们就可以表示1到2^k-1的数了，对于剩下的x个我们也可以表示：


我们假设将x向前平移x个，因为平移后x所在的区域小于2^k-1，所以我们可以直接表示出来，用这些值加上已知的x就可以表示x这个范围内的数了，这样1到n就全部都能表示出来了。

然后老师又拿出之前的一道题来给我们思考，这道题就是天平，在天平一端上放一个重量为1到n之间的砝码，要我们用n个重为1的砝码放在天平的两端，使天平平衡。问如何分组可以使n个天平与所有重量为1到n之间的砝码平衡。

这道题不像上一道，这道题可以在天平的两边放，也就是说可以加也可以减，最后我们推算到这个数列：1、3、9、27…全都是3的次方，证明也很简单，转成三进制就可以了。

那么这种数列有什么运用呢？多重背包就是了，之前我做多重背包的题时都是把多件物品拆成独立的一件，这样就大大增加了时间复杂度与空间复杂度，再后来我用这种方法做，但也要三重循环：
```cpp
#include <fstream>

using namespace std;

ifstream fin("Dp.in");

ofstream fout("Dp.out");

 

int n,m,a[2000],b[2000],c[2000],f[1000];

int main()

{

  fin>>n>>m;

  for (int i=1;i<=n;++i) fin>>c[i]>>a[i]>>b[i];   //读入

  for (int i=1;i<=n;++i)

   for (int j=m;j>=a[i];--j)

    for (int k=1;k<=c[i];++k)    //枚举物品各种数量的情况

     if (j-a[i]*k<0) break; else   

      if (f[j-a[i]*k]+b[i]*k>f[j]) f[j]=f[j-a[i]*k]+b[i]*k;

  for (int i=1;i<=m;++i) fout<<f[i]<<endl;

  return 0;   

}

现在我们可以用之前的方法拆分物品，也可以表示各种数量的物品。这样一来就可以大大减少时间复杂度：

#include <fstream>

using namespace std;

ifstream fin("Dp2.in");

ofstream fout("Dp2.out");

 

void init();

void work();

int k[2000],v[2000],s[2000],f[500],n,m,t;

int main()

{

  init();

  work(); 

  return 0;   

}

 

void init()

{

  int num,weight,cost,x;

  fin>>n>>m;

  t=1;   //记得要初始化为1

  for (int i=1;i<=n;++i)

   {

     fin>>num>>weight>>cost;

     x=1;     //记得x的初始化要在每次读入之后，因为每件物品都需要拆分，每次拆分的起点都是1.

     for (;num!=0;)        

      {

        if (num>=x) k[t]=x; else k[t]=num;

//防止num被拆成了负数

        num=num-k[t]; 

        v[t]=weight*k[t];   

  //将物品拆分1份1组、2份1组、4份1组、8份1组……

        s[t]=cost*k[t];      //记得要乘以一个k

        ++t;

        x=x*2;        

      }       

   }     

}

 

void work()

{

   for (int i=1;i<=t;++i)

    for (int j=m;j>=v[i];--j)

     if (f[j-v[i]]+s[i]>f[j]) f[j]=f[j-v[i]]+s[i]; 

//拆分之后直接01背包就可以了

   fout<<f[m]<<endl;

}
```

<br/><br/>
