# 01背包与优化
## 算法详解与优化
给出n件物品的重量和价值，然后给出一个最大装载重量为W的背包，问如何取舍这n件物品，在不超过背包最大装载重量的情况下令背包中物品价值最大。

设```f[i][j]```表示当背包重量为j时，从前i件物品中能达到的最大价值。然后从第0件物品开始遍历到第n-1件物品，对于第i件物品（假设其重量为```w[i]```，价值```v[i]```），我们可以选择将其放入背包，也可以选择不放，我们直接比较这两种策略带来的价值即可，即```f[i][j] = max(f[i-1][j-w[i]]+v[i], f[i-1][j])```。

空间优化：由于```f[i]```的值全部更新自```f[i-1]```，```f[i-2]```一直到```f[0]```都没用了，因此f数组没有必要一直记录历史值，第一维可省略：
```cpp
// f[j]: 表示当背包重量为j时，当前背包中物品的最大价值
for (int i=0; i<n; ++i)
    for (int j=W; j>=w[i]; --j)
        f[j] = max(f[j-w[i]]+v[i], f[j]);
```

上述代码中要注意j的循环应从大到小进行。如果是从小到大进行，```f[j]```可能会被```f[j-w[i]] + v[i]```更新，而```f[j-w[i]]```可能会被```f[j-2*w[i]] + v[i]```更新，以此类推，相当于第i件物品被反复放入背包中，与题意不符。

## LeetCode相关题目
### [LeetCode 2915](https://leetcode.com/problems/length-of-the-longest-subsequence-that-sums-to-target/)

给出一个数组和一个目标值，从数组中选出若干元素形成一个子序列，要求子序列元素和等于目标值。输出满足条件的最长子序列长度。

```f[i]```表示当子序列元素和为i时子序列的最长长度。需要注意的是在状态转移的时候，当```f[j-a[i]]```等于-1时，说明目前还没有子序列的和为```j-a[i]```，此时不能进行状态转移。
```cpp
class Solution {
public:
    int lengthOfLongestSubsequence(vector<int>& a, int t) {
        vector<int> f (t+1, -1);
        f[0] = 0;
        for (int i=0; i<a.size(); ++i)
            for (int j=t; j>=a[i]; --j)
                if (f[j-a[i]] != -1)
                    f[j] = max(f[j], f[j-a[i]] + 1);
        return f[t];
    }
};
```

<br/><br/>

# 完全背包与优化
给出n种物品的重量和价值，然后给出一个最大装载重量为W的背包，每种物品有无限多件，问在不超过背包最大装载重量的情况下如何装载这些物品，令背包中物品价值最大。

完全背包的思路其实和01背包一样。在01背包代码中，为了避免第i件物品被反复放入背包中，内层循环是从大到小执行。我们将内层循环改成从小到大执行，即为完全背包的代码：
```cpp
// f[j]: 表示当背包重量为j时，当前背包中物品的最大价值
for (int i=0; i<n; ++i)
    for (int j=w[i]; j<=W; ++j)
        f[j] = max(f[j-w[i]]+v[i], f[j]);
```
## LeetCode相关题目
### [LeetCode 518](https://leetcode.com/problems/coin-change-ii/)

给出一个数组和一个目标值，从数组中取出若干元素形成组合（数组中的每个数均可无限使用），组合中的所有元素和等于目标值。输出满足条件的不同组合的数量。

基本上就是完全背包的模型。```f[i]```表示达成目标值i的组合的方案数。
```cpp
class Solution {
public:
    int change(int k, vector<int>& a) {
        vector<int> f (k+1, 0);
        f[0] = 1;
        for (int i=0; i<a.size(); ++i)
            for (int j=a[i]; j<=k; ++j) 
                f[j] += f[j-a[i]];
        return f[k];
    }
};
```
<br/><br/>


# 石子分组与多重背包优化
    
有n个石子，问如何将他们分组，使他们可以表示1到n的任何数（比如说分成三组，这三组分别为1，2，3，那么我们可以表示的数为1、2、3、1+3、2+3、1+2+3即1、2、3、4、5、6），现在要使分的组最少。
类似的题型以前也接触过，所以也不算难。

首先我们分析一下，要表示1，则必须要分出只有一个石块的一组，而要表示2则又要分出只有两个石块的一组，这时我们可以表示1、2、3了，那么接下来要表示4的话需不需要分出三个石子为一组呢？如果这样做，我们可以表示1、2、3、4、6，但5就无法表示了，所以这样做是行不通的，如果分出四个石子为一组的话就可以表示1、2、3、4、5、6、7，我们继续推理下去，就可以发现分组的石子数量为1、2、4、8、16、32……

但为什么这种分组的方法可以表示1到n的任何数？我们可以先将这些数用二进制表示：1、10、100、1000、10000……这样对于10000这个数我们可以通过前面的数来决定它后面的四位是零还是一，对于1000、100、10都是一样，这样我们就可以表示1到2^k-1的数了，对于剩下的x个我们也可以表示：


我们假设将x向前平移x个，因为平移后x所在的区域小于2^k-1，所以我们可以直接表示出来，用这些值加上已知的x就可以表示x这个范围内的数了，这样1到n就全部都能表示出来了。

然后老师又拿出之前的一道题来给我们思考，这道题就是天平，在天平一端上放一个重量为1到n之间的砝码，要我们用n个重为1的砝码放在天平的两端，使天平平衡。问如何分组可以使n个天平与所有重量为1到n之间的砝码平衡。

这道题不像上一道，这道题可以在天平的两边放，也就是说可以加也可以减，最后我们推算到这个数列：1、3、9、27…全都是3的次方，证明也很简单，转成三进制就可以了。

那么这种数列有什么运用呢？多重背包就是了，之前我做多重背包的题时都是把多件物品拆成独立的一件，这样就大大增加了时间复杂度与空间复杂度，再后来我用这种方法做，但也要三重循环：
```cpp
#include <fstream>

using namespace std;

ifstream fin("Dp.in");

ofstream fout("Dp.out");

 

int n,m,a[2000],b[2000],c[2000],f[1000];

int main()

{

  fin>>n>>m;

  for (int i=1;i<=n;++i) fin>>c[i]>>a[i]>>b[i];   //读入

  for (int i=1;i<=n;++i)

   for (int j=m;j>=a[i];--j)

    for (int k=1;k<=c[i];++k)    //枚举物品各种数量的情况

     if (j-a[i]*k<0) break; else   

      if (f[j-a[i]*k]+b[i]*k>f[j]) f[j]=f[j-a[i]*k]+b[i]*k;

  for (int i=1;i<=m;++i) fout<<f[i]<<endl;

  return 0;   

}

现在我们可以用之前的方法拆分物品，也可以表示各种数量的物品。这样一来就可以大大减少时间复杂度：

#include <fstream>

using namespace std;

ifstream fin("Dp2.in");

ofstream fout("Dp2.out");

 

void init();

void work();

int k[2000],v[2000],s[2000],f[500],n,m,t;

int main()

{

  init();

  work(); 

  return 0;   

}

 

void init()

{

  int num,weight,cost,x;

  fin>>n>>m;

  t=1;   //记得要初始化为1

  for (int i=1;i<=n;++i)

   {

     fin>>num>>weight>>cost;

     x=1;     //记得x的初始化要在每次读入之后，因为每件物品都需要拆分，每次拆分的起点都是1.

     for (;num!=0;)        

      {

        if (num>=x) k[t]=x; else k[t]=num;

//防止num被拆成了负数

        num=num-k[t]; 

        v[t]=weight*k[t];   

  //将物品拆分1份1组、2份1组、4份1组、8份1组……

        s[t]=cost*k[t];      //记得要乘以一个k

        ++t;

        x=x*2;        

      }       

   }     

}

 

void work()

{

   for (int i=1;i<=t;++i)

    for (int j=m;j>=v[i];--j)

     if (f[j-v[i]]+s[i]>f[j]) f[j]=f[j-v[i]]+s[i]; 

//拆分之后直接01背包就可以了

   fout<<f[m]<<endl;

}
```

<br/><br/>
