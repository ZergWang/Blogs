# 最长公共子序列 
题目链接：[LeetCode 1143](https://leetcode.com/problems/longest-common-subsequence/)

给出两个字符串s1和s2，求出这两个字符串最长公共子序列的长度。

新建二维数组f，其中f[i][j]表示将s1前i位构成的子串，转换为s2前j位构成的子串，需要的最少步数。举个例子，假设s1为“intention”，s2为“execution”，则f[3][5]表示将“int”转换为“execu”所需的最少步数。
```cpp
int Max(int x, int y) {return x > y ? x : y;}
int longestCommonSubsequence(char * s1, char * s2){
    int n1 = strlen(s1), n2 = strlen(s2);
    int f[n1][n2];
    memset(f, 0, sizeof(f));

    f[0][0] = s1[0] == s2[0] ? 1 : 0;
    for (int i=1 ;i<n1; i++)
        if (s2[0] == s1[i])
            f[i][0] = 1;
        else 
            f[i][0] = f[i-1][0];
    
    for (int i=1 ;i<n2; i++)
        if (s1[0] == s2[i])
            f[0][i] = 1;
        else 
            f[0][i] = f[0][i-1];
    
    for (int i=1; i<n1; i++)
        for (int j=1; j<n2; j++) {
            if (s1[i]==s2[j])
                f[i][j] = f[i-1][j-1] + 1;
            else 
                f[i][j] = Max(f[i-1][j], f[i][j-1]);
        }
    
    return f[n1-1][n2-1];
}
```
<br/><br/>

# 字符串转换
题目链接：[LeetCode 72](https://leetcode.com/problems/edit-distance/)

给出两个字符串s1和s2，问最少需要几步能将s1转换成s2。以下三种操作，均算作一步：
- 增：在s1的任意位置加一个字符。
- 删：将s1的任意一个字符删除。
- 改：将s1中的任意一个字符改成另一个字符。

新建二维数组f，其中f[i][j]表示将s1前i位构成的子串，转换为s2前j位构成的子串，需要的最少步数。举个例子，假设s1为“intention”，s2为“execution”，则f[3][5]表示将“int”转换为“execu”所需的最少步数。

对于将s1前i位转换成s2的前j位，可分别通过以下三种操作实现，其中：
- 增：将s1前i位转换成s2的前j-1位，然后在字符串末尾补上s2的第j位。
- 删：将s1前i-1位转换成s2的前j位，然后再删掉字符串末尾的字符（也就是原来s1的第i位）。
- 改：将将s1前i-1位转换成s2的前j-1位，然后将字符串末尾的字符（即原来s1的第i位）改成s2的第j位。当然，如果s1的第i位等于s2的第j位，则不用改。

由此可得状态转移方程：
$$ f(i, j) =\begin{cases}
min(f(i-1, j)+1, f(i,j-1)+1, f(i-1, j-1))  & s1[i-1] = s2[j-1] \\
min(f(i-1, j), f(i,j-1), f(i-1, j-1))+1  & s1[i-1] \neq s2[j-1]
\end{cases}$$

```cpp
int minDistance(char * s1, char * s2){
    int n1 = strlen(s1), n2 = strlen(s2);
    if (!n1 || !n2)
        return max(n1, n2);
    
    int f[n1+1][n2+1];
    memset(f, 0, sizeof(f));
    
    for (int i=1; i<=n1; i++)
        f[i][0] = i;

    for (int i=1; i<=n2; i++)
        f[0][i] = i;

    for (int i=1; i<=n1; i++)
        for (int j=1; j<=n2; j++) 
            if (s1[i-1]==s2[j-1])
                f[i][j] = min(f[i-1][j]+1, f[i][j-1]+1, f[i-1][j-1]);
            else 
                f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1])+1;
    
    
    return f[n1][n2];
}
```