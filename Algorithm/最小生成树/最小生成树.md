# 问题引入
**一个有n个节点m条边（m>=n）且边有权值的无向图，它的最小生成树就是在所有边中选出n-1条边组成一棵树，且所选边的权值和最小。**
拿实际问题来举例。假如有n个地点，现在要修路将这n个地点相互连通，每条路连通两个地点，但不同的路造价不一样。问如何修路，使得所有地点都能连通，但路的造价最低。
<br/><br/>

# Kruskal算法
首先将所有边从图中去除，并将这些边按权值从小到大排序，然后从权值最小的边开始逐个检验：若该边加入到图中后未出现环，则该边保留到图中，然后再检验下一条边，直到选出n-1条边。

对于环的判断，可使用并查集进行处理。假设当前检验的边连接的两点的根节点相同，说明这两点在加入该边前就已经连通，则加入此边后必定有环。
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int maxn=1000;
struct node{ int a,b,c;};
node f[maxn];
int n,m,father[maxn],ans[maxn]; 

bool cmp(node a,node b){
    return a.c<b.c;
}

int find_r(int x){
    if (father[x]!=x) father[x]=find_r(father[x]);
    return father[x];
}

int main(){
    cin>>n>>m;    //给出n个顶点m条边的无向图
    for (int i=1;i<=m;i++) cin>>f[i].a>>f[i].b>>f[i].c; //.a与.b放相连的两定点，.c放边的权值
    sort(f+1,f+1+m,cmp);
    int x1,x2;
    for (int i=1;i<=n;i++) father[i]=i;       //并查集必须的初始化
    for (int i=1;i<=m;i++){
        x1=find_r(f[i].a);         //找两点的祖先
        x2=find_r(f[i].b);
        if (x1!=x2){              //如果两点无共同祖先说明两点之前并不相连
            ans[i]=true;      //因此这条边要加入该树
            father[x1]=father[x2];
        }
    }
    for (int i=1;i<=m;i++) if (ans[i]) cout<<f[i].a<<f[i].b<<f[i].c<<endl;
    return 0;
}
```
<br/><br/>

# Prim算法
 从任意一点开始，然后搜索与之相连的点中边权值最小的连接，然后对于这两个点都搜索相连的点，如果某个点连上后有环则放弃该点。若有权值相同的两点则任选一个（因为最后所有点都是要搜索其相邻点的）。
<br/><br/>

# 参考资料



