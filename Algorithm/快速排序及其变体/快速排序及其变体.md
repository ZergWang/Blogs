# 快速排序（Quick Sort）
#### 原理解析
步骤如下：

1. 对于要排序的区间，先定一个”基准数“k，基准数可随机指定，也可指定区间第一个或最后一个为基准数，但一般是以区间中心的数为基准数。下面以区间中心的数为基准数进行升序排序为例进行讲解。

2. 从区间末端向前，找到第一个小于等于k的数；同时从区间开头向后，找到第一个大于等于k的数。

3. 将找到的这两个数交换位置，然后从当前位置继续向前（向后）找，重复步骤2，3，直到遍历完整个区间。

4. 遍历完整个区间后，k已经被放置到正确的位置上，在k前面的数都比它小，在k后面的数都比它大，这个时候采用分治策略，对k之前的区间和k之后的区间重复2、3、4步。

举个例子，以5为基准数：

![](快速排序及其变体_1.png)
<br/>
接下来，以3为基准数：

![](快速排序及其变体_2.png)
#### 代码
```cpp
void QuickSort(int* a, int lef, int rig){
    if (lef >= rig) return;
    int i = lef, j = rig;
    int mid = i+(j-i)/2;
    int k = a[mid];
    while (i<=j){   //这里和下面if处的判断条件中都有等号，虽然i==j的情况下循环和swap没有意义，但仍需要i和j的移动，否则会进入死循环
        while (a[i]<k) i++;    //这里为了能移动基准数，所以判断条件不能带等号
        while (a[j]>k) j--;
        if (i<=j) swap(a[i++], a[j--]);     
    }
    QuickSort(a, i, rig);
    QuickSort(a, lef, j);
}
```
<br/><br/>

# 快速排序稳定化改造
对于给定的区间，确定基准数k后，新建两个数组a1和a2，其中a1用于存储区间中所有比k小的数，a2存储所有比k大的数，然后按a1, k, a2的顺序将三者覆盖回原来的数组（区间），之后同样用分治策略递归排序a1部分和a2部分即可。
```cpp
void QuickSort(int* a, int lef, int rig){
    if (lef >= rig) return;
    int n = rig-lef+1;
    int a1[n], a2[n], n1 = 0, n2 = 0;
    int mid = lef+(rig-lef)/2;
    int k = a[mid];

    for (int i=lef; i<=rig; i++) 
        if (i != mid) {
            if (a[i]<k)
                a1[n1++] = a[i];
            else if (a[i]>k) 
                a2[n2++] = a[i];
            else {
                if (i<mid)
                    a1[n1++] = a[i];
                else 
                    a2[n2++] = a[i];
            }
        }
    
    for (int i=lef; i<lef+n1; i++)
        a[i] = a1[i-lef];

    a[lef+n1] = k;
    
    for (int i=rig-n2+1; i<=rig; i++)
        a[i] = a2[i-rig+n2-1];
    
    QuickSort(a, lef, lef+n1-1);
    QuickSort(a, rig-n2+1, rig);
}
```

# Quick Select算法


# 参考资料及部分图片来源
[稳定版快速排序算法](https://bitjoy.net/2016/08/18/the-stable-quick-sort/)

[Stable QuickSort](https://www.geeksforgeeks.org/stable-quicksort/)

[Quicksort 快速排序算法](https://www.cnblogs.com/chuangweili/articles/5159645.html)
