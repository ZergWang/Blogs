# LeetCode 1630
题目链接：https://leetcode.com/problems/arithmetic-subarrays/

若一个数组中的元素按某种顺序排列后能形成等差数列，则该数组是“arithmetic”的。现在给出数组a以及若干个询问，每个询问包含两个数i和j，问a[i]至a[j]这一段子数组是否为“arithmetic”的。

判断数组中元素能否构成等差数列，最简单的想法就是排序，排序后查看相邻两元素的差是否相等。该方法需要的时间复杂度为$O(N \times log N)$。

实际上，可以通过等差数列通项公式将时间复杂度降至$O(N)$。在得知项数（即N）的情况下，找出数组中的最大值max和最小值min，即可计算得到公差$d = \frac{max-min}{N}$。然后，对于数组中的任一元素k，若k能作为等差数列的一部分，则它在等差数列中是第$\frac{k-min}{d}+1$项。因此，我们只需要一个额外的bool数组，来判断等差数列中的每一项是否在数组中均有元素对应即可。

```cpp
bool GetAns(int* a, int lef, int rig) {
    int min = a[lef], max = a[rig];

    for (int i=lef; i<=rig; i++) {
        min = a[i] < min ? a[i] : min;
        max = a[i] > max ? a[i] : max;
    }
    
    if (min==max)
        return 1;
    if ((max-min)%(rig-lef)!=0) 
    //由于数组为int型，若计算得到的公差为小数的话，则绝对不可能构成等差数列
        return 0;

    int d = (max-min)/(rig-lef);
    bool f[505];
    memset(f, 0, sizeof(f));
    for (int i=lef; i<=rig; i++) {
        if ((a[i]-min)%d != 0)
            return 0;
        if (f[(a[i]-min)/d])
            return 0;
        f[(a[i]-min)/d] = 1;
    }
    return 1;
}

bool* checkArithmeticSubarrays(int* a, int n, int* l, int lSize, int* r, int rSize, int* returnSize){
    *returnSize = lSize;
    bool *ans = (bool*)malloc(lSize*sizeof(bool));

    for (int i=0; i<lSize; i++)
        ans[i] = GetAns(a, l[i], r[i]);

    return ans;
}
```



