# 引入

单调队列一般用于求解区间最值问题。给出一个含n个数的序列，求该序列中每个宽度为k的区间的最值。暴力算法需要$O(nk)$的时间复杂度，而单调队列仅需$O(n)$。

<br/><br/>

# 单调队列详解
## 定义

单调队列具有单调性，其内部元素从队首至队尾是单调递增或递减的。单调队列底层通过双端队列（double-ended queue，简称deque）来实现。和普通队列相比，双端队列的队尾不仅能加入元素（入队操作），也能删除元素（即出队操作）。

单调队列的队首元素一定是单调队列中的最值，也是当前维护区间的最值。


## 单调队列维护过程
假设要维护指定宽度的区间的最大值。对于每个序列中的元素，在入队前要与单调队列队尾元素比较，若大于队尾元素，则队尾元素出队，然后再与新的队尾元素比较，直到不大于队尾元素或队列为空，然后再将该元素从队尾入队。

同时，还要检测队首元素是否超出当前维护区间的范围，若超出也要出队。

举个例子，给出以下序列元素，求出每个宽度为3的区间的最大值。
```
1 3 -1 -3 5 3 6 7
```
单调队列的维护过程，如下所示：（假设左侧为队首）

| 操作 | 队列状态 | 
| -- |  -- |
| 1入队 | ```1``` |
| 3 > 1，1出队，3入队| ```3 ```|
| -1 < 3，-1入队 |  ```3 -1 ```|
| -3 < -1，-3入队| ```3 -1 -3```|
| 5大于所有队中元素，队中元素依次出队，5入队| ```5```|
| 3 < 5，3入队 | ```5 3```|
| 6 > 3且6 > 5，3和5依次出队，6入队| ```6```|
| 7 > 6，7入队| ```7```|


对于n个数的序列，单调队列在维护指定区间的最值时，每个数最多入队一次，出队一次，每次出入队的时间复杂度为$O(1)$，因此总体的时间复杂度可以优化成$O(n)$。

## 与单调栈的关系

单调队列的性质和单调栈非常类似。在单调队列中，如果其队首元素已经处于指定区间之外，则可以直接在队首执行出队操作，因此单调队列可以维护指定区间的单调性。单调栈可以视为一种无法在队首执行出队操作的单调队列，因此单调栈维护的是所有入栈元素的单调性。

<br/><br/>


# 相关例题
## LeetCode 239
题目链接：https://leetcode.com/problems/sliding-window-maximum/

给出一个含n个数的序列，求该序列中每个宽度为k的区间的最值。

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<pair<int, int>> a;  // first存储元素的值，second存储元素的坐标
        vector<int> ans;
        for (int i = 0; i<nums.size(); ++i) {
            while (!a.empty() && nums[i] > a.back().first) 
                a.pop_back();   //依次与队尾元素比较
            a.emplace_back(nums[i], i);
            if (a.front().second <= i-k) //若队首元素不属于当前计算区间，则出队
                a.pop_front();
            if (i >= k-1)
                ans.push_back(a.front().first);
        }
        return ans;
    }
};
```