# 归并排序（Merge Sort）
一般指二路归并排序，是稳定排序，原理如下：

归并排序分为两个过程，一是通过递归不断将数组二分，直到无法再二分进行第二步：合并，具体如图：
![](归并排序及其变体_1.png)
二分过程通过递归很好实现，合并过程的详细过程为：

首先要明确两个事实：一是这两个要合并的序列不一定等长（数组总长度不可能总是2的次方），但这并不妨碍合并过程；二是因为通过递归，每个要合并的序列本身已经是有序的了。

合并过程如下：另开一个数组c，存储合并后的有序（这里以降序排序为例）序列，设两个待合并序列为a和b，对a[1]与b[1]进行比较，若a[1]更大，则将a[1]放入c[1]，a、c指针后移。然后比较a[2]与b[1]，较大者放入c[2]并移动指针，以此类推。当a或b中全部数字移入c中，可将另一序列中剩余数字按原顺序一次性移入。最后将数组c中的有序序列移回原数组。

#### 递归写法
```cpp
void Merge_Sort(int lef, int rig){
    if (lef == rig) return;
 
    int b[N];
    int mid = lef + (rig-lef)/2;
    Merge_Sort(lef, mid);
    Merge_Sort(mid+1, rig);
    
    int i = lef;
    int lp = lef;
    int rp = mid+1;
 
    while (i <= rig){
        if (a[lp]<a[rp]){
            b[i] = a[lp];
            lp++;
        } else{
            b[i] = a[rp];
            rp++;
        }
        i++;
 
        if (lp > mid){
            for (int j=i; j <= rig; j++) b[j] = a[rp+j-i];
            break;
        } else
        if (rp > rig){
            for (int j=i; j <= rig; j++) b[j] = a[lp+j-i];
            break;
        }        
    }
 
    for (int j=lef; j <= rig; j++) a[j] = b[j];
}
```
#### 非递归写法
通过上图可知，一开始合并时，每个序列长度为1（仅一个数字），然后当所有长度为1的序列两两合并后，每个待合并序列长度为2，然后是4、8、16……因此，我们可以省去递归二分的过程，直接通过上述规律对相应序列进行合并。代码如下：
```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;
 
#define N 1000007
int n, a[N], b[N];
 
void MergeSort();
void JustMerge(int lef, int mid, int rig);
 
int main(){
    scanf("%d", &n);
    for (int i=1; i <= n; i++) scanf("%d", &a[i]);
    MergeSort();
    for (int i=1; i <= n; i++) printf("%d ", a[i]);
    return 0;
}
 
void MergeSort(){
    int step = 1, i = 1;
    while (step < n){
        while (i-1+step*2 <= n){
            JustMerge(i, i-1+step, i-1+step*2);
            i += step*2;
        }
        if (n-i+1 > step) JustMerge(i, i-1+step, n);//后一个序列长度与前一个稍短，也可合并
        //但若剩下的项连一个序列都凑不齐，则不管
        step *= 2;    //step即序列长度
        i = 1;
    }
}
 
void JustMerge(int lef, int mid, int rig){
    if (lef == rig) return;
    
    int i = lef;
    int lp = lef;
    int rp = mid+1;
 
    while (i <= rig){
        if (a[lp]<a[rp]){
            b[i] = a[lp];
            lp++;
        } else{
            b[i] = a[rp];
            rp++;
        }
        i++;
 
        if (lp > mid){
            for (int j=i; j <= rig; j++) b[j] = a[rp+j-i];
            break;
        } else
        if (rp > rig){
            for (int j=i; j <= rig; j++) b[j] = a[lp+j-i];
            break;
        }        
    }
 
    for (int j=lef; j <= rig; j++) a[j] = b[j];
}
```
<br/><br/>

# 参考资料及部分图片来源
[归并排序 —— 递归实现 + 非递归实现](https://www.cnblogs.com/jijizhazha/p/6127274.html)
