# 内联函数

类的成员函数，如果其定义也在类的声明中，则该函数默认为内联函数。

若成员函数的定义在类的声明外，但也想令其成为内联函数，加入“inline”关键字：
```cpp
inline void 类名::成员函数名() {
    ...
}
```
# 构造函数
## 定义与声明
```cpp
class 类名 {
public:
    类名(参数);    //声明
};

类名::类名(参数) { //定义
    ...
}
```
同一个类下可定义多个不同参数表的构造函数，调用时会根据传参自动选择对应版本的构造函数。
## 默认构造函数
如果用户没有定义任何构造函数，则编译器会隐式定义一个无任何参数的构造函数，而且该函数中不作任何操作：
```cpp
类名::类名() {}
```
无任何参数，或者参数都有默认值的构造函数被称为默认构造函数，上述编译器隐式定义的就是一个默认构造函数。

如果用户定义了某种构造函数，但没有定义默认构造函数，此时编译器并不会隐式定义默认构造函数。此时使用无参数的构造函数创建对象会报错。

## 拷贝构造函数
当使用一个左值对象来创建新对象时，会调用拷贝构造函数，如果用户没有定义拷贝构造函数，编译器会隐式生成一个。
```cpp
//假设有一个class Time
Time a {1,2};
Time b(a);
Time c {a}; // b、c都会调用拷贝构造函数Time::Time(const Time &)
```
编译器隐式生成的拷贝构造函数会以浅拷贝的方式在对象间传递值，这将带来潜在风险。如有需要用户应显式定义拷贝构造函数。
```cpp
class Time {
private:
    int h, m; //hour, minute
public:
    Time(const Time & t) {    //显示声明拷贝构造函数
        minute = t.minute;
        hour = t.hour;
    }
}
```

## 移动构造函数
如果使用一个右值对象来构造函数，编译器会隐式生成移动构造函数。隐式生成的移动构造函数采用浅拷贝的方式在对象间传递值，但不会对右值对象作额外处理（例如将右值对象的指针置为nullptr），这也可能带来潜在问题。

如果需要使用一个原有的对象来创建新对象，且希望新对象直接替代原有对象，而不是让新对象存储在新的内存地址处，应显式地定义移动构造函数：
```cpp
class Time {
public:
    Time(Time && t) {//形参为右值引用变量
        h = t.h;
        m = t.m;
        //假设有指针类型的成员p，则p = t.p; t.p = nullptr;
    }
};

Time t2 {std::move(t1)}; //调用
```
由于是在原有对象的地址上将新对象直接替换到原有对象，移动构造函数中新成员赋值采用浅拷贝，被拷贝的对象中指针类型的成员赋值为nullptr即可。

## 构造函数调用
以下均可调用构造函数进行初始化：
```cpp
类名 对象名;      //调用默认构造函数

类名 对象名(参数); //调用指定参数形式的构造函数

类名 对象名 {参数}; //列表初始化，调用指定参数形式的构造函数
```

由于在使用构造函数构造对象之前，对象是不存在的，因此使用“对象名.构造函数()”方式构造对象是非法的。

在对象的声明处使用“=”赋值运算符并不会调用默认或重载的赋值运算符函数，因此以下两种构造函数的调用，前者调用对应参数版本的普通构造函数，后者调用拷贝构造函数。
```cpp
类名 对象名 = 构造函数名(参数);

类名 对象名 = 对象名;
```

类也可以作为数组的基本类型，同样支持列表初始化，未被初始化的数组元素将调用默认构造函数：
```cpp
//调用不同的构造函数来初始化数组元素，a[2]被默认构造函数初始化
类名 a[4] {类名(参数), 类名(参数, 参数), 类名()}; 
```
## 成员初始化列表
构造函数一般用于给对象的各个成员赋值，对此，有一种较为简便的构造函数写法，称为成员初始化列表，在函数头后使用“对象名(参数)”的形式来初始化对象，这等价于在函数中“对象名 = 参数;”。

沿用上面Time类的例子：
```cpp
Time::Time(int t1, int t2): h(t1), m(t2) {
    ...
}
```
如果对象有一些成员强制需要初始化（比如引用变量或者常量），但类的声明中无法存储初始化值。使用成员初始化列表可解决上述矛盾：（假设Time类有私有成员```Time & t```）
```cpp
Time::Time(Time & out_time): t(out_time) {
    ...
} 
```
C++11标准允许对普通成员不包括静态成员、引用变量等）声明的同时进行初始化（这一操作实际上是隐式使用成员初始化列表功能完成的）。但如果类的成员要根据外部变量初始化，还得通过构造函数来实现。

使用成员初始化列表其效率要比普通的初始化方法更高一些。

<br/><br/>

# 析构函数
一般来说析构函数无需特意编写，令编译器隐式生成即可。若要自行定义，则：
```cpp
~类名();          //析构函数声明

类名::~类名() {   //析构函数定义
    ... 
}
```
通常不应显式调用析构函数，令编译器自行决定即可（编译器一般在程序结束时调用析构函数，函数里面的操作也会被执行。但通过new生成的对象，编译器一般不会自动调用析构函数，需要手动操作）。

<br/><br/>

# const成员与成员函数
## const成员
和普通成员一样声明和初始化，区别就是加了一个const关键字。

## const成员函数
若某个成员函数不会修改对象的任何成员，则可以将该成员函数定义为const成员函数：
```cpp
返回值类型  函数名(参数) const;           //const成员函数声明

返回值类型  类名::函数名(参数) const {    //const成员函数定义
    ...
}
```
在const成员函数中无法修改成员，也无法调用其他非const的成员函数。


若某个对象被定义为const，则可以直接调用该对象的const成员函数，但调用普通成员函数则会报错（因为编译器无法保证这些函数不会修改其成员）。

<br/><br/>

# 静态成员与成员函数 
## this指针
在类的构造函数、析构函数及成员函数中，若要表示对象本身，可使用关键字“this”。this是一个指针，指向该函数所属对象的地址。

this指针隐式地作为所有非静态成员函数的首个参数。举个例子：
```cpp
class Time {
private:
    int h, m; //hour, minute
public:
    void ShowTime(string s);
}
```
实际上ShowTime的参数表为：
```cpp
void ShowTime(Time * const this, string s) 
```

而在成员函数中要调用某个成员，表面上我们通过成员名即可调用，实际上通过“this->成员名”方式调用。

this指针不是类的成员，对象不存储this指针。this指针存储在栈区，在执行成员函数时被创建，成员函数结束时被销毁。

## 静态成员

所有类的静态成员和普通静态变量一样都存储在内存静态区中，不占用对象的存储空间。无论实例化多少个对象，所有的对象都共享同一个静态成员，因此静态成员可以跨对象使用。如果静态成员无const限定，每个对象都可修改这个共享的静态成员。在类的声明外静态成员需要通过```类名::静态成员名```来访问（通过对象调用静态成员一般也不会报错，但不建议如此操作）。

对于无const的静态成员，其初始化必须在类的声明外进行。
```cpp
class 类名 {
private:
    static int n;
};
//即使n是private的在此也可访问，因为静态变量的初始化也被视为在类中的操作
int 类名::n = 12;  
```

如果是const static的成员，可以在类的声明中直接初始化。
```cpp
class 类名 {
private:
    const static int n = 12;
};
```

C++17标准允许静态变量在类内初始化：
```cpp
class 类名 {
private:  //需加入inline关键字
    inline static int n = 12;
};
```

## 静态成员函数
```cpp
class 类名 {
private:
    static void 函数名 { ... }
}
```
静态成员函数一样不属于任何对象，因此静态成员函数中无法使用this指针，也无法访问任何类的非静态成员。但与静态成员不同，静态成员函数存储在内存的代码段，而不是静态区中。

对静态成员函数的访问通过```类名::静态成员函数名```进行（通过对象调用静态成员函数一般也不会报错，但不建议如此操作）。


<br/><br/>

# 运算符重载
## 重载规则
1. 只能重载C++本身存在的运算符，比如“+”、“-”、“*”、“[]”等，不可重载C++中不存在的运算符。
2. 重载不能改变运算符原来的优先级、结合性、操作数。
3. 有些运算符不能重载，如“sizeof”、成员运算符（“.”）、作用域解析运算符（“::”）等
4. 有些运算符能重载，但只能作为成员函数进行重载
## 作为成员函数的运算符重载
类中的运算符重载可以看作是一种特殊的成员函数，该函数既可以像普通成员函数一样调用，也可以用指定运算符调用。

例如，为下面的类重载“+”运算符：
```cpp
class Time {
private:
    int h, m; // hour, minute
public:
    Time operator+(const Time &t) const;
};

Time Time::operator+(const Time &t) const {
    Time sum;
    sum.m = m + t.m;
    sum.h = h + t.h + sum.m / 60;
    sum.m %= 60;
    return sum;
}

int main() {
    Time a {1, 30};
    Time b {3, 40};
    Time c = a.operator+(b); //按普通成员函数的方式调用
    Time c = a + b;          //按重载运算符的方式调用
}
```
“+”运算符需要两个操作数。在按重载运算符的方式调用时，函数隐含的this指针指代了第一个操作数，参数指代了第二个操作数，因此```a+b```等价于```a.operator+(b)```。

另外，运算符重载后支持如同```a + b + c + ... + d```的连续调用。通过额外定义一个```Time::operator+(int t) const```的运算符重载，还可以实现```a+10```的操作。

## 非成员函数的运算符重载
上述的运算符重载解决了```a+10```这种操作问题，但是对于```10+a```却无能为力。因为10本身并不是一个对象，无法通过10调用其成员函数，此时需要通过非成员函数的方式来实现：
```cpp
Time operator+(int minute, const Time & t)
``` 
该函数是普通函数，参数表中没有隐含的this指针，因此需要两个参数来对应两个操作数。该函数也不能直接访问Time的private成员。因此，我们还需进一步将上述函数声明为Time类的友元函数：
```cpp
class Time {
public:
    friend Time operator+(int minute, const Time & t);
};
//友元函数的定义无需加friend关键字，由于友元函数不是成员函数，无需Time::
Time operator+(int minute, const Time & t) {
    Time ans;
    ans.m = t.m + minute;
    ans.h = t.h + ans.m / 60;
    ans.m %= 60;
    return ans;
}
```
友元函数也不是类的成员函数，因此友元函数没有this指针。在友元函数内部，无论是从参数中传入的对象，还是临时定义的对象，只要是Time类的，所有成员（包括private）均可访问。

实际上，不通过友元函数，使用以下普通函数（该函数也不是成员函数）也能实现```10+a```的操作形式：
```cpp
Time operator+(int minute, const Time & t) {
    return t + minute;
}
``` 
这里嵌套调用了成员函数```Time::operator+(int t) const```，避免了对类的private成员的直接访问。

综上所述，要想实现```10+a```的操作，使用成员函数还是非成员函数均可，但不能两个都用，这是因为函数重载会同时匹配上这两个函数，从而导致编译错误。



## 重载赋值运算符
将一个对象用“=”赋值给另一个对象，如果用户没有显式重载赋值运算符，编译器会隐式地生成赋值运算符的重载，并用浅拷贝的方式在对象间传递值，如果有指针类型的成员，浅拷贝会带来潜在的风险。因此如果有需要，应显式地重载赋值运算符。

### 拷贝赋值运算符
将左值对象赋值给其他对象时，编译器会隐式生成拷贝赋值运算符的重载。

重载赋值运算符，如果有指针类型的成员或者深拷贝的需要，应显式重载拷贝赋值运算符：
```cpp
class Time {
public:
    Time & operator=(const Time &t) {
        h = t.h;
        m = t.m;
        return *this;
    }
};
```
注意：在对象声明的同时使用“=”赋值不会调用默认或重载的赋值运算符函数：
```cpp
Time t2 = t1; //调用拷贝构造函数
Time t3;
t3 = t2; //调用默认或重载的赋值运算符函数
```

### 移动赋值运算符
将右值对象赋值给其他对象时，编译器会隐式生成移动赋值运算符的重载。

类似移动构造函数，如果希望让当前对象接管另一个对象的资源而不引入潜在的bug，应显式重载移动赋值运算符：
```cpp
class Time {
public:
    Time & operator=(Time && t) {
        //假设有指针类型的成员p，则p = t.p; t.p = nullptr;
        h = t.h;
        m = t.m;
        return *this;
    }
};

int main(){
    Time t1 {1,2};
    Time t2;
    t2 = std::move(t1); 
}
```

## 重载类型转换函数
可以将类的对象转换成指定数据类型。例如，重载Time的bool类型转换函数，可以令Time的对象参与逻辑运算。
```cpp
class Time {
public:
    operator bool() const {
        if (h == 0 && m == 0)
            return 0;
        return 1;
    }
};

int main() {
    Time t;
    if (t) 
        ...
}
```
## 重载输入输出
```cpp
class Time {
public:
    friend ostream & operator<<(ostream &output, const Time &t) { 
        output << "hour: " << t.h << " minute: " << t.m;
        return output;            
    }
    //由于输入会改变对象，因此参数中不能加const限定
    friend istream & operator>>(istream &input, Time &t) { 
        input >> t.h >> t.m;
        return input;            
    }
};

int main() { 
    Time t;
    cin >> t; //以下调用形式也可： operator>>(cin, t); 
    cout << t; //operator<<(cout, t);
}
```


# default/delete声明

综上所述，如果用户没有自行声明，编译器会隐式生成默认构造函数、拷贝构造函数、析构函数以及构造赋值运算符的重载函数。

如果用户声明了带参数的构造函数，但没有声明默认构造函数，通过无参数形式创建对象编译器会报错，此时可以用以下简便方式声明一个默认构造函数，而且无需提供该函数的定义。
```cpp
class Time {
public:
    Time() = default;//使用=default效率要比自行定义默认构造函数更高
    Time & operator=(const Time &t) = delete;
};
```

如果用户自己没有声明默认构造函数、拷贝构造函数等函数，也不希望编译器隐式生成。可以在这类函数后加上“=delete”，这样一来相当于完全关闭了使用这个函数的渠道，用户无法使用，编译器也不会自行生成。例如上面就关闭了“=”重载函数，对于Time类的对象就无法进行赋值操作。

default关键字只能用于以下六种编译器会隐式生成的函数上：
```cpp
Time() = default;                         //默认构造函数
Time(const Time &t) = default;            //拷贝构造函数
Time(Time && t) = default;                //移动构造函数
Time & operator=(const Time &t) = default;//拷贝赋值运算
Time & operator=(Time && t) = default;    //移动赋值运算
~Time() = default;                        //析构函数
```

delete可用于除纯虚函数外所有成员函数上。

# 类的大小
类的size一般指在堆或栈上为一个类分配的空间大小，主要受到其成员、继承关系以及虚表指针三个因素的影响。类的成员函数存储在内存代码区中，不影响类的size；静态成员存储在数据段或BSS段，因此也不影响类的size。this指针不属于类的成员，也不影响类的size。

以下类的大小的计算结果，适用于64位系统且默认最大对齐数为8的情况。

## 普通类的大小
如果类没有继承自某个基类，其size取决于自身所有非静态成员（和结构体一样遵循对齐规则）。

如果有继承关系，类的size的计算方法与结构体嵌套的size一样，将基类视为派生类的首个成员：
```cpp
class A {   // A的对齐数为1，size为3，
public:
    char a1, a2, a3;
};

class B : public A{
public:
    int b1;
    char b2;
    short b3;
};
```
在计算B的size时，可视为：
```cpp
class B{    //此时B的size为12
public:
    A;        //存储在地址0处
    int b1;   //地址4
    char b2;  //地址8
    short b3; //地址10
};
```

如果上述类A和B中有虚函数的话，虚表指针视为类的首个成员。此时在嵌套计算基类的大小时就不需要考虑基类的虚表指针了。

在计算A的size时可视为：
```cpp
class A {   // 此时A的size为16
public:
    虚表指针   //对齐数为8，存储在地址0处
    char a1, a2, a3; //分别存储在8，9，10处
};
```
在计算B的size时，可视为：
```cpp
class B{    // 此时B的size为24
public:
    虚表指针   //对齐数为8，存储在地址0处
    A;        //无需考虑A的虚表指针，A存储在地址8处
    int b1;   //地址12
    char b2;  //地址16
    short b3; //地址18
};
```

## 空类的大小
没有成员类的size恒为1，即使实例出对象，对象的size也为1。（为了区分每个对象，每个对象都有自己独有的内存地址，因此对象的size最小为1）。
```cpp
class A {};
class B: public A {};
int main() {
    A a;      
    cout << sizeof(A) << " " << sizeof(a);// 输出1 1
    B b;
    cout << sizeof(B) << " " << sizeof(b);// 输出1 1
}
```
类B继承了一个空类，但编译器通过优化，令类B的size不受空的基类影响，其size仍为1。
<br/><br/>
