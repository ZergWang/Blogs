**类中声明的变量与成员函数，一般统称为类的成员。**

# 内联函数

类的成员函数，如果其定义也在类的声明中，则该函数默认为内联函数。

若成员函数的定义在类的声明外，但也想令其成为内联函数，加入“inline”关键字：
```cpp
inline void 类名::成员函数名() {
    ...
}
```
# 构造函数
## 定义与声明
```cpp
class 类名 {
public:
    类名(参数);    //声明
};

类名::类名(参数) { //定义
    ...
}
```
同一个类下可定义多个不同参数表的构造函数，调用时会根据传参自动选择对应版本的构造函数。
## 默认构造函数
如果用户没有定义任何构造函数，则编译器会隐式定义一个无任何参数的构造函数，而且该函数中不作任何操作：
```cpp
类名::类名() {}
```
无任何参数，或者参数都有默认值的构造函数被称为默认构造函数，上述编译器隐式定义的就是一个默认构造函数。

如果用户定义了某种构造函数，但没有定义默认构造函数，此时编译器并不会隐式定义默认构造函数。此时使用无参数的形式创建对象会报错。

## 拷贝构造函数
当使用一个已有的对象来创建新对象时，会调用拷贝构造函数，如果用户没有定义拷贝构造函数，编译器会隐式生成一个。
```cpp
//假设有一个class Time
Time a {1,2};
Time b(a);
Time c {a}; // b、c都会调用拷贝构造函数Time::Time(const Time &)
```
编译器隐式生成的拷贝构造函数会将形参各个成员的值浅拷贝给新对象的各个成员，这将带来潜在风险。如有需要用户应显式定义拷贝构造函数。
```cpp
class Time {
private:
    int hour, minute;
public:
    Time(const Time & t) {    //显示声明拷贝构造函数
        minute = t.minute;
        hour = t.hour;
    }
}
```

## 移动拷贝构造函数
使用一个已有的对象来创建新对象，新对象直接生成在已有对象的内存地址处，继承已有对象的值，因此无需额外分配空间：
```cpp
class Time {
public:
    Time(Time && t); 
    //移动拷贝构造函数的声明，形参为右值引用变量
};

Time t2 {std::move(t1)}; //调用
```
由于是在已有对象的地址上将新对象直接替换到原有对象，移动拷贝构造函数中成员采用浅拷贝，然后将被拷贝的对象中指针类型的成员赋值为nullptr即可。

## 构造函数调用
以下均可调用构造函数进行初始化：
```cpp
类名 对象名;      //调用默认构造函数

类名 对象名(参数); //调用指定参数形式的构造函数

类名 对象名 {参数}; //列表初始化，调用指定参数形式的构造函数

类名 对象名 = 构造函数名(参数);
```
由于在使用构造函数构造对象之前，对象是不存在的，因此使用“对象名.构造函数()”方式构造对象是非法的。

一般```类名 对象名(参数);```的构造效率要比```类名 对象名 = 构造函数名(参数);```更高，这是由于后者涉及到赋值，可能导致编译器创建一个临时对象后，调用析构函数，再将该临时对象赋值给我们需要的目标对象，除非重载拷贝赋值运算符。

类也可以作为数组的基本类型，同样支持列表初始化，未被初始化的数组元素将调用默认构造函数：
```cpp
class Stock{
    ...
};
//调用不同的构造函数来初始化数组元素，a[3]被默认构造函数初始化
Stock a[4] {Stock(1), Stock(2,3), Stock()}; 
```
## 成员初始化列表
构造函数一般用于给对象的各个成员赋值，对此，有一种较为简便的构造函数写法，称为成员初始化列表，现在假设有个类叫Time，其中有私有成员hour和minute，则：
```cpp
Time::Time(int h, int m): hour(h), minute(m) {
    ...
}
//在函数头后使用“对象名(参数名)”等价于在函数中“对象名 = 参数名;”
```
括号中也可填入常量或表达式，例如：
```cpp
Time::Time(): hour(0), minute(0) {
    ...
}
```
如果对象有一些成员强制需要初始化（比如引用变量或者常量），但类的声明中无法存储初始化值。使用成员初始化列表可解决上述矛盾：（假设Time类有私有成员```Time & t```）
```cpp
Time::Time(Time & out_time): t(out_time) {
    ...
} 
```
C++11标准允许在类的声明中将类的普通成员（不包括静态成员、引用变量等）初始化字面量，这一操作实际上是隐式使用成员初始化列表功能完成的。但如果类的成员要根据外部变量初始化，还得通过构造函数来实现。

使用成员初始化列表来为类的成员赋值或初始化，其效率要比普通方法更高一些。

<br/><br/>

# 析构函数
一般来说析构函数无需特意编写，令编译器隐式生成即可。若要自行定义，则：
```cpp
~类名();          //析构函数声明

类名::~类名() {   //析构函数定义
    ... 
}
```
通常不应显式调用析构函数，令编译器自行决定即可（编译器一般在程序结束时调用析构函数，函数里面的操作也会被执行。但通过new生成的对象，编译器一般不会自动调用析构函数，需要手动操作）。

<br/><br/>


# 静态成员， const成员与this指针
## const成员
若某个成员函数不会修改对象的任何成员，则可以将该成员函数定义为const成员函数：
```cpp
返回值类型  函数名(参数) const;           //const成员函数声明

返回值类型  类名::函数名(参数) const {    //const成员函数定义
    ...
}
```
若某个对象被定义为const，则可以直接调用该对象的const成员函数，但调用普通成员函数则会报错（因为编译器无法保证这些函数不会修改其成员）。

## this指针
在类的构造函数、析构函数及成员函数中，若要表示对象本身，可使用关键字“this”。this是一个指针，指向该函数所属对象的地址。

this指针隐式地作为所有非静态成员函数的首个参数。举个例子：
```cpp
class People {
public:
    int age;
    string name;
    bool FindPeople(string s) {
        ...
    }
}
```
实际上FindPeople函数的参数表为：
```cpp
bool FindPeople(People * const this, string s) 
```

而在成员函数中要调用某个成员，表面上我们通过成员名即可调用，实际上通过“this->成员名”方式调用。

## 静态成员
C++11之前，类的对象不能在类的声明时初始化，这是因为类的声明仅描述了对象的形式，并没有创建对象，因此也没有空间去存储这些初始化的值。如果类中需要一个常量成员，只能使用枚举类型或者static const关键字：
```cpp
class 类名 {
private:
    static const int n = 12;
}
```
所有类的静态成员和普通静态变量一样都存储在内存静态区中。因此n与其他静态变量存储在一起，并不会占用对象的存储空间。

无论实例化多少个对象，所有的对象都共享同一个静态成员，因此静态成员可以跨对象使用。如果静态成员无const限定，每个对象都可修改这个共享的静态成员。

对于无const的静态成员，其初始化必须在类的声明外进行。由于静态成员不属于任何对象，在类的声明外静态成员需要通过```类名::静态成员名```来访问。
```cpp
class 类名 {
private:
    static int n;
}

int 类名::n = 12;  //即使n是private的在此也可访问
```

静态成员函数一样不属于任何对象，因此静态成员函数中无法使用this指针，也无法访问任何类的非静态成员。

对静态成员函数的访问通过```类名::静态成员函数名```进行。


<br/><br/>

# 运算符重载
## 重载规则
1. 只能重载C++本身存在的运算符，比如“+”、“-”、“*”、“[]”等，不可重载C++中不存在的运算符。
2. 重载不能改变运算符原来的优先级、结合性、操作数。
3. 有些运算符不能重载，如“sizeof”、成员运算符（“.”）、作用域解析运算符（“::”）等
4. 有些运算符能重载，但只能作为成员函数进行重载
## 作为成员函数的运算符重载
类中的运算符重载可以看作是一种特殊的成员函数，该函数既可以像普通成员函数一样调用，也可以用指定运算符调用。

例如，为下面的类重载“+”运算符：
```cpp
class Time {
private:
    int h, m; // hour, minute
public:
    ...
    Time operator+(const Time &t) const;
};

Time Time::operator+(const Time &t) const {
    Time sum;
    sum.m = m + t.m;
    sum.h = h + t.h + sum.m / 60;
    sum.m %= 60;
    return sum;
}

int main() {
    Time a {1, 30};
    Time b {3, 40};
    Time c = a.operator+(b); //按普通成员函数的方式调用
    Time c = a + b;          //按重载运算符的方式调用
}
```
“+”运算符需要两个操作数。在按重载运算符的方式调用时，函数隐含的this指针指代了第一个操作数，参数指代了第二个操作数，因此```a+b```等价于```a.operator+(b)```。

另外，运算符重载后支持如同```a + b + c + ... + d```的连续调用。通过额外定义一个```Time::operator+(int t) const```的运算符重载，还可以实现```a+10```的操作。

## 非成员函数的运算符重载
上述的运算符重载解决了```a+10```这种操作问题，但是对于```10+a```却无能为力。因为10本身并不是一个对象，无法通过10调用成员函数，此时需要通过非成员函数的方式来实现：
```cpp
Time operator+(int minute, const Time & t)
``` 
由于上述函数是非成员函数，参数表中没有隐含的this指针，因此需要两个参数来对应两个操作数。另外。由于是非成员函数，不能对t的private成员直接访问。因此，我们还需进一步将上述函数声明为Time类的友元函数：
```cpp
class Time {
public:
    ...
    friend Time operator+(int minute, const Time & t);
};
//友元函数的定义无需加friend关键字，由于友元函数不是成员函数，无需Time::
Time operator+(int minute, const Time & t) {
    Time ans;
    ans.m = t.m + minute;
    ans.h = t.h + ans.m / 60;
    ans.m %= 60;
    return ans;
}
```
虽然友元函数声明在类中，但它并不是类的成员函数，因此友元函数没有this指针。在友元函数内部，无论是从参数中传入的对象，还是临时定义的对象，只要是Time类的，所有成员（包括private）均可访问。

实际上，不通过友元函数，使用以下普通函数（该函数也不是成员函数）也能实现```10+a```的操作形式：
```cpp
Time operator+(int minute, const Time & t) {
    return t + minute;
}
``` 
这里嵌套调用了成员函数```Time::operator+(int t) const```，避免了对类的private成员的直接访问。

综上所述，要想实现```10+a```的操作，使用成员函数还是非成员函数均可，但不能两个都用，这是因为函数重载会同时匹配上这两个函数，从而导致编译错误。



## 重载赋值运算符：构造赋值运算符，移动赋值运算符
将一个对象用“=”赋值给另一个对象，如果用户没有显式重载“=”，编译器会隐式地生成“=”的重载，并用浅拷贝的方式将一个对象所有成员的值赋值给另一个对象，这同样会带来潜在的风险。因此如果用户需要使用“=”给对象赋值，应显式地重载“=”符号。



## 重载类型转换函数
可以将类的对象转换成指定数据类型。例如，重载Time的bool类型转换函数，可以令Time的对象参与逻辑运算。
```cpp
class Time {
private:
    int h, m, s;
public:
    Time(int hour, int minute, int second): 
        h(hour), m(minute), s(second) {};

    operator bool() const {
        if (h == 0 && m == 0 && s == 0)
            return 0;
        return 1;
    }
};

int main() {
    Time t {1,2,3};
    if (t) 
        ...
}
```



# 函数的隐式生成与default/delete声明

综上所述，如果用户没有自行声明，编译器会隐式生成默认构造函数、拷贝构造函数、析构函数以及构造赋值运算符的重载函数。

如果用户声明了带参数的构造函数，但没有声明默认构造函数，通过无参数形式创建对象编译器会报错，此时可以用以下简便方式声明一个默认构造函数，而且无需提供该函数的定义。
```cpp
class Time {
public:
    Time() = default;//使用=default效率要比自行定义默认构造函数更高
    Time(int t1, int t2): h(t1), m(t2) {}
    Time & operator=(const Time &t) = delete;
};
```

如果用户自己没有声明默认构造函数、拷贝构造函数等函数，也不希望编译器隐式生成。可以在这类函数后加上“=delete”，这样一来相当于完全关闭了使用这个函数的渠道，用户无法使用，编译器也不会自行生成。例如上面就关闭了“=”重载函数，对于Time类的对象就无法进行赋值操作。

“=default”只能用于少数几种编译器可以隐式生成的函数上（比如默认构造函数、拷贝构造函数等），但“=delete”可以用除纯虚函数外所有成员函数上。
<br/><br/>
