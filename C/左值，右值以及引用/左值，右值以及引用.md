# 左值与右值
对于C语言来说，左值就是字面意义上能出现在赋值符号（即“=”符号）左边的值。然而在C++中，左值被认为是可以被取地址且拥有自己变量名的值。也就是说，字面量或者表达式不是左值。
<br/><br/>

# 引用变量
## 性质
在使用上，引用变量可视为变量的“别名”，对两者取值、取地址的结果都是一样的。

本质上来说，引用变量是一种指向普通变量的特殊指针常量：
```cpp
int a = 10;
int & b = a;
// int * const p = &a;
//b可以看作是特殊版本的指针常量p
```
和指针常量相同之处：引用变量需要在声明时初始化。而且必须将相应类型的变量（而不是字面量或表达式）赋值给引用变量，否则会报错。

和指针常量不同之处：在使用引用变量时，“\*”运算符会被隐式调用。若对引用变量显式使用“\*”则会报错。

由于引用变量可视为变量的“别名”，因此对引用变量的修改和赋值，本质上都是对被引用变量的修改。引用变量也可以像普通变量一样被赋值给其他普通变量或引用变量。
```cpp
b = 20;
//b的表现与 *p 类似，上述语句类似于 *p = 20;
int c = 30;
b = c; //等价于a = c
```

## 引用变量的使用及const关键字的影响

### 普通引用变量
引用变量在定义时加上了const关键字（即```const int & b = a;```），则对引用变量的修改就会报错，其他地方与不加const的引用变量一致。

### 作为函数参数的引用变量

引用变量作为函数参数，且没有const关键字限定时，实参必须为对应类型的左值，否则编译器将报错。在实参满足要求的前提下，调用函数时作为形参的引用变量会被隐式地初始化为实参。

如果有const关键字限定，函数调用时对实参的要求则会更宽松：实参类型可以与引用变量不一致，实参也可以不为左值。这是因为在这种情况下，函数被调用时，会自动为实参生成一个临时变量，其类型与引用变量一致，但值等于实参。在函数中，引用变量会引用这个临时变量。临时变量在函数结束后会被销毁，因此函数的执行不会改变实参。而且在函数中，引用变量也不可被赋值等语句修改。
### 作为函数返回值的引用变量

函数的返回值为引用变量类型时，函数可作为左值使用，举个例子，假设现在有一个非常复杂的数据类型T，以及这样的一个函数：能修改实参，同时还能返回实参修改后的结果。
```cpp
T & Add(T & a) {
    ... //假设这里是对a修改的代码
    return a;  // 这里等价于生成一个引用变量，并令其引用a
    // 注意：此时不可return函数中的临时变量，否则会报错
}

int main() {
    T a, b;
    ...
    b = Add(a);
    //该语句合法，本质上来说等价于b = a;
    Add(a) = b; 
    //该语句合法，将b赋值给引用a的变量，本质上来说等价于a = b;
}
```
但如果作为函数返回值的引用变量加上const限定，则```Add(a) = b;```则不合法了。因为const不允许对引用变量进行修改。


## 引用变量的应用
一般会将引用变量作为函数参数或返回值使用，可起到简化程序的作用，主要有以下三点好处：
### 简化参数
指针降维，无需在函数中处理多重指针。
### 无需判空
相较于指针，引用变量在声明时必须初始化，因此其必不为空，因此无需判空。

### 提高效率
函数被调用时会新建一个临时变量作为形参，其值等于对应的实参。如果函数参数是某种复杂数据类型，则新建临时变量的开销会比较大。

如果参数是无const关键字的引用变量，函数调用时新建的则是引用变量，开销则比较稳定且代价较小（开销约等于新建一个指针常量）。

同理，函数的返回值也会存储到一个临时变量中，当临时变量赋值给其他变量后，或者作为参数进入其他函数后才会被销毁。如果返回值类型也比较复杂，新建临时变量也会严重影响程序运行效率。

如果返回值是引用变量，则函数返回时新建的是一个引用变量，开销约等于新建一个指针常量，例如上面的```T & Add(T & a)```函数，```b = Add(a);```相当于将a的引用直接赋值给b，无需额外开辟内存给复杂数据类型。


<br/><br/>




<br/><br/>
