# 左值与右值
对于C语言来说，左值就是字面意义上能出现在赋值符号（即“=”符号）左边的值。然而在C++中，左值被认为是可以被取地址且拥有自己变量名的值。也就是说，变量名一般为左值，而字面量或者表达式是右值。
<br/><br/>

# 左值引用
## 性质
引用变量即“左值引用”。当引用变量无const修饰时，其引用对象只能为左值。

在使用上，引用变量可视为左值的“别名”，对两者取值、取地址的结果都是一样的。

本质上来说，引用变量是一种指向普通左值的特殊指针常量：
```cpp
int a = 10;
int & b = a;
// int * const p = &a;
//b可以看作是特殊版本的指针常量p
```
和指针常量相同之处：引用变量需要在声明时初始化。而且必须将相应类型的左值（而不是字面量或表达式）赋值给引用变量，否则会报错。

和指针常量不同之处：在使用引用变量时，“\*”运算符会被隐式调用。若对引用变量显式使用“\*”则会报错。

由于引用变量可视为左值的“别名”，因此对引用变量的修改和赋值，本质上都是对被引用的左值的修改。引用变量也可以像普通左值一样被赋值给其他左值或引用变量。
```cpp
b = 20;
//b的表现与 *p 类似，上述语句类似于 *p = 20;
int c = 30;
b = c; //等价于a = c
```

## 特殊数据类型的引用
普通变量、指针、数组、类的对象都可以有对应的引用类型。其中，数组的引用类型声明比较特殊：

```cpp
int a[] {1,2,3};
int (&b)[3] = a; 
```
b作为a的引用类型，在声明时不仅要求数组类型一致，还强制要求数组长度一致，否则会报错。


## 引用变量的使用及const关键字的影响

### 普通引用变量
引用变量在定义时加上了const关键字（即```const int & b = a;```），则对引用变量的修改就会报错，其他地方与不加const的引用变量一致。

另外，有const关键字的引用变量可以引用右值：
```cpp
const int & b = 10; 
```

### 作为函数参数的引用变量

如果没有const关键字限定，实参必须为对应类型的左值，否则编译器将报错。在实参满足要求的前提下，调用函数时，形参作为引用变量，会隐式执行引用传递。

如果有const关键字限定，在函数中不可修改引用变量类型的形参。另外函数调用时对实参的要求则会更宽松：实参类型可以与引用变量不一致，实参也可以不为左值。若实参类型与形参一致，则执行引用传递。若不一致，函数调用时，会自动为实参生成一个临时变量，该临时变量的类型与形参一致，但值与实参一致。

### 作为函数返回值的引用变量
函数的返回值为引用变量类型时，函数可作为左值使用，举个例子，假设现在有一个非常复杂的数据类型T，以及这样的一个函数：能修改实参，同时还能返回实参修改后的结果。
```cpp
T & Add(T & a) {
    ... //假设这里是对a修改的代码
    return a;  // 这里等价于生成一个引用变量，并令其引用a
    // 注意：此时不可return函数中的临时变量，否则会报错
}

int main() {
    T a, b;
    ...
    b = Add(a);
    //该语句合法，本质上来说等价于b = a;
    Add(a) = b; 
    //该语句合法，将b赋值给引用a的变量，本质上来说等价于a = b;
}
```
但如果作为函数返回值的引用变量加上const限定，函数返回值就成为了右值，```Add(a) = b;```不合法，因为const不允许对函数返回值作修改。


## 引用变量的应用
一般会将引用变量作为函数参数或返回值使用，可起到简化程序的作用，主要有以下三点好处：
### 简化参数
指针降维，无需在函数中处理多重指针。
### 无需判空
相较于指针，引用变量在声明时必须初始化，因此其必不为空，因此无需判空。

### 提高效率
函数被调用时会新建一个临时变量作为形参，其值等于对应的实参。如果函数参数是某种复杂数据类型，则新建临时变量的开销会比较大。

如果参数是无const关键字的引用变量，函数调用时新建的则是引用变量，开销则比较稳定且代价较小（开销约等于新建一个指针常量）。

同理，函数的返回值也会存储到一个临时变量中，当临时变量赋值给其他变量后，或者作为参数进入其他函数后才会被销毁。如果返回值类型也比较复杂，新建临时变量也会严重影响程序运行效率。

如果返回值是引用变量，则函数返回时新建的是一个引用变量，开销约等于新建一个指针常量，例如上面的```T & Add(T & a)```函数，```b = Add(a);```相当于将a的引用直接赋值给b，无需额外开辟内存给复杂数据类型。


<br/><br/>

# 右值引用
## 性质
一种可以引用右值的引用变量，声明方式：
```cpp
// 类型 && 引用变量名 = 右值;
int a = 5;
int && b = 10;  
int && c = a + 10;
```
右值引用变量绑定的右值在特定区域存储，以右值引用变量c为例，c绑定了a+10的结果（也就是15），15被存储在某个内存空间中。之后即使a的值变了，c仍与15这个结果绑定。另外，对c可以取地址。

如果要右值引用变量去引用一个左值，必须使用```std::move(左值)```函数将左值变为右值：
```cpp
int a = 10; 
int && b = std::move(a);
```
一般为了避免潜在的名字冲突，调用move函数必须使用std的作用域解析运算符。

## 作用
右值引用的意义在于，强调被引用的右值（或std::move作用的左值）是临时的，很快或很可能被销毁。当然这种强调并不是强制的。即使对左值使用了std::move函数，这个左值之后也可继续正常使用。

在面向对象中，移动构造函数以及移动赋值运算符重载函数的形参一般为右值引用变量，从而令新对象直接取代形参对应的对象，无需额外分配内存空间。

<br/><br/>
