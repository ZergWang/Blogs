# 类的成员
类中声明的变量与成员函数，一般统称为类的成员。
## 类的内联函数

类的成员函数，如果其定义也在类的声明中，则该函数默认为内联函数。

若成员函数的定义在类的声明外，但也想令其成为内联函数，加入“inline”关键字：
```cpp
inline void Stock::set_tot() {
    ...
}
```
## 构造函数
### 定义与声明
```cpp
class 类名 {
public:
    类名(参数);    //声明
};

类名::类名(参数) { //定义
    ...
}
```
同一个类下可定义多个不同参数表的构造函数，调用时会根据传参自动选择对应版本的构造函数。
### 默认构造函数
如果用户没有定义任何构造函数，则编译器会隐式定义一个无任何参数的构造函数，而且该函数中不作任何操作：
```cpp
类名::类名() {}
```
无任何参数，或者参数都有默认值的构造函数被称为默认构造函数，上述编译器隐式定义的就是一个默认构造函数。

如果用户定义了某种构造函数，但没有定义默认构造函数，此时编译器并不会隐式定义默认构造函数。此时使用无参数的形式创建对象会报错。

### 拷贝构造函数
当使用一个已有的对象来创建新对象时，会调用拷贝构造函数，如果用户没有定义拷贝构造函数，编译器会隐式生成一个。
```cpp
//假设有一个class Time
Time a {1,2};
Time b = a;  
Time c(a);
Time d {a}; // b、c、d都会调用拷贝构造函数Time::Time(const Time &)
```
然而，编译器隐式生成的拷贝构造函数，会将形参的各个成员的值浅拷贝给新对象的各个成员，这将带来潜在风险。因此用户应尽量显式地定义拷贝构造函数。

### 移动拷贝构造函数
使用一个已有的对象来创建新对象，令新对象直接生成在已有对象的地址处，无需额外分配空间：
```cpp
class Time {
public:
    ...
    Time(Time && t); 
    //移动拷贝构造函数的声明，形参为右值引用变量
};

Time t2 {std::move(t1)}; //调用
```
由于是在已有对象的地址上将新对象直接替换到原有对象，移动拷贝构造函数中成员采用浅拷贝，然后将已有对象的指针指向nullptr即可。

和移动拷贝构造函数类似的还有移动赋值运算符重载函数，通过重载“=”来实现与移动拷贝构造函数相同的功能。这里不作展开。

### 构造函数调用
以下均可调用构造函数进行初始化：
```cpp
类名 对象名;      //调用默认构造函数，若无定义默认构造函数，该语句报错

类名 对象名(参数);

类名 对象名 = 构造函数名(参数);

// 由于在使用构造函数构造对象之前，对象是不存在的，因此不可通过以下方式调用构造函数：
对象名.构造函数();
```
一般```类名 对象名(参数);```的构造效率要比```类名 对象名 = 构造函数名(参数);```更高，这是由于后者涉及到赋值，可能导致编译器创建一个临时对象后，调用析构函数，再将该临时对象赋值给我们需要的目标对象，除非重载拷贝赋值运算符。

C++11支持对类的列表初始化（只要大括号中的参数与某个构造函数的参数表匹配即可）：
```cpp
类名 对象名 {参数};
```

类也可以作为数组的基本类型，同样支持列表初始化，未被初始化的数组元素将调用默认构造函数：
```cpp
class Stock{
    ...
};
//调用不同的构造函数来初始化数组元素，a[3]未通过列表初始化，将调用默认构造函数
Stock a[4] {Stock(1), Stock(2,3), Stock()}; 
```
### 成员初始化列表
构造函数一般用于给对象的各个成员赋值，对此，有一种较为简便的构造函数写法，称为成员初始化列表，现在假设有个类叫Time，其中有私有成员hour和minute，则：
```cpp
Time::Time(int h, int m): hour(h), minute(m) {
    ...
}
//在函数头后使用“对象名(参数名)”等价于在函数中“对象名 = 参数名;”
```
括号中也可填入常量或表达式，例如：
```cpp
Time::Time(): hour(0), minute(0) {
    ...
}
```
如果对象有一些成员强制需要初始化（比如引用变量或者常量），但类的声明中无法存储初始化值。使用成员初始化列表可解决上述矛盾：（假设Time类有私有成员```Time & t```）
```cpp
Time::Time(Time & out_time): t(out_time) {
    ...
} 
```
C++11标准允许在类的声明中将类的普通成员（不包括静态成员、引用变量等）初始化字面量，这一操作实际上是隐式使用成员初始化列表功能完成的。但如果类的成员要根据外部变量初始化，还得通过构造函数来实现。


使用成员初始化列表来为类的成员赋值或初始化，其效率要比普通方法更高一些。

## 析构函数
一般来说析构函数无需特意编写，令编译器隐式生成即可。若要自行定义，则：
```cpp
~类名();          //析构函数声明

类名::~类名() {   //析构函数定义
    ... 
}
```
通常不应显式调用析构函数，令编译器自行决定即可（编译器一般在程序结束时调用析构函数，函数里面的操作也会被执行。但通过new生成的对象，编译器一般不会自动调用析构函数，需要手动操作）。

## const成员函数
若某个成员函数不会修改对象的任何成员，则可以将该成员函数定义为const成员函数：
```cpp
返回值类型  函数名(参数) const;           //const成员函数声明

返回值类型  类名::函数名(参数) const {    //const成员函数定义
    ...
}
```
若某个对象被定义为const，则可以直接调用该对象的const成员函数，但调用普通成员函数则会报错（因为编译器无法保证这些函数不会修改其成员）。

## this指针
在类的构造函数、析构函数及成员函数中，若要表示对象本身，可使用关键字“this”。this是一个指针，指向该函数所属对象的地址。

this指针隐式地作为所有非静态成员函数的首个参数。举个例子：
```cpp
class People {
public:
    int age;
    string name;
    bool FindPeople(string s) {
        ...
    }
}
```
实际上FindPeople函数的参数表为：
```cpp
bool FindPeople(People * const this, string s) 
```

而在成员函数中要调用某个成员，表面上我们通过成员名即可调用，实际上通过“this->成员名”方式调用。

## 静态成员
C++11之前，类的对象不能在类的声明时初始化，这是因为类的声明仅描述了对象的形式，并没有创建对象，因此也没有空间去存储这些初始化的值。如果类中需要一个常量成员，只能使用枚举类型或者static const关键字：
```cpp
class 类名 {
private:
    static const int n = 12;
}
```
所有static型变量都存储在一起，定义在类中的static变量也不例外。因此n与其他static变量存储在一起，并不会占用对象的存储空间。

无论实例化多少个对象，所有的对象都共享同一个静态成员，因此无const的静态成员可以跨对象使用，每个对象都可修改共享的这个静态成员。

对于无const的静态成员，其初始化需要在类的声明外进行。由于静态成员不属于任何对象，所以对它的访问需要通过```类名::静态成员名```进行。
```cpp
class 类名 {
private:
    static int n;
}

int 类名::n = 12;
```

静态成员函数一样不属于任何对象，因此静态成员函数中无法使用this指针，也无法访问任何类的非静态成员。

对静态成员函数的访问通过```类名::静态成员函数名```进行。


<br/><br/>

## 运算符重载
### 作为成员函数的运算符重载
类中的运算符重载可以看作是一种特殊的成员函数，该函数既可以像普通成员函数一样调用，也可以用指定运算符调用。

例如，为下面的类重载“+”运算符：
```cpp
class Time {
private:
    int h, m; // hour, minute
public:
    ...
    Time operator+(const Time &t) const;
};

Time Time::operator+(const Time &t) const {
    Time sum;
    sum.m = m + t.m;
    sum.h = h + t.h + sum.m / 60;
    sum.m %= 60;
    return sum;
}

int main() {
    Time a {1, 30};
    Time b {3, 40};
    Time c = a.operator+(b); //按普通成员函数的方式调用
    Time c = a + b;          //按重载运算符的方式调用
}
```
“+”运算符需要两个操作数。在按重载运算符的方式调用时，函数隐含的this指针指代了第一个操作数，参数指代了第二个操作数，因此```a+b```等价于```a.operator+(b)```。

另外，运算符重载后支持如同```a + b + c + ... + d```的连续调用。通过额外定义一个```Time::operator+(int t) const```的运算符重载，还可以实现```a+10```的操作。

### 非成员函数的运算符重载
上述的运算符重载解决了```a+10```这种操作问题，但是对于```10+a```却无能为力。因为10本身并不是一个对象，无法通过10调用成员函数，此时需要通过非成员函数的方式来实现：
```cpp
Time operator+(int minute, const Time & t)
``` 
由于上述函数是非成员函数，参数表中没有隐含的this指针，因此需要两个参数来对应两个操作数。另外。由于是非成员函数，不能对t的private成员直接访问。因此，我们还需进一步将上述函数声明为Time类的友元函数：
```cpp
class Time {
public:
    ...
    friend Time operator+(int minute, const Time & t);
};
//友元函数的定义无需加friend关键字，由于友元函数不是成员函数，无需Time::
Time operator+(int minute, const Time & t) {
    Time ans;
    ans.m = t.m + minute;
    ans.h = t.h + ans.m / 60;
    ans.m %= 60;
    return ans;
}
```
虽然友元函数声明在类中，但它并不是类的成员函数，因此友元函数没有this指针。在友元函数内部，无论是从参数中传入的对象，还是临时定义的对象，只要是Time类的，所有成员（包括private）均可访问。

实际上，不通过友元函数，使用以下普通函数（该函数也不是成员函数）也能实现```10+a```的操作形式：
```cpp
Time operator+(int minute, const Time & t) {
    return t + minute;
}
``` 
这里嵌套调用了成员函数```Time::operator+(int t) const```，避免了对类的private成员的直接访问。

综上所述，要想实现```10+a```的操作，使用成员函数还是非成员函数均可，但不能两个都用，这是因为函数重载会同时匹配上这两个函数，从而导致编译错误。

### 运算符重载的限制
1. 只能重载C++本身存在的运算符，比如“+”、“-”、“*”、“[]”等，不可重载C++中不存在的运算符。
2. 重载不能改变运算符原来的优先级、结合性、操作数。
3. 有些运算符不能重载，如“sizeof”、成员运算符（“.”）、作用域解析运算符（“::”）等
4. 有些运算符能重载，但只能作为成员函数进行重载

### 赋值符号的隐式重载
将一个对象用“=”赋值给另一个对象，如果用户没有显式重载“=”，编译器会隐式地生成“=”的重载，并用浅拷贝的方式将一个对象所有成员的值赋值给另一个对象，这同样会带来潜在的风险。因此如果用户需要使用“=”给对象赋值，应显式地重载“=”符号。

## 函数的default与delete声明

综上所述，如果用户没有自行声明，编译器会隐式生成默认构造函数、拷贝构造函数、析构函数以及赋值运算符的重载函数。

如果用户声明了带参数的构造函数，但没有声明默认构造函数，通过无参数形式创建对象编译器会报错，此时可以用以下简便方式声明一个默认构造函数，而且无需提供该函数的定义。
```cpp
class Time {
public:
    Time() = default;//使用=default效率要比自行定义默认构造函数更高
    Time(int t1, int t2): h(t1), m(t2) {}
    Time & operator=(const Time &t) = delete;
};
```

如果用户自己没有声明默认构造函数、拷贝构造函数等函数，也不希望编译器隐式生成。可以在这类函数后加上“=delete”，这样一来相当于完全关闭了使用这个函数的渠道，用户无法使用，编译器也不会自行生成。例如上面就关闭了“=”重载函数，对于Time类的对象就无法进行赋值操作。

“=default”只能用于少数几种编译器可以隐式生成的函数上（比如默认构造函数、拷贝构造函数等），但“=delete”可以用在所有成员函数上。
<br/><br/>

# 类的继承

## 继承方式
```cpp
class 派生类名 : public 基类名 { //公有继承
    ...
};
```
公有继承（public）：派生类继承基类的公有成员和访问成员，这些成员的访问权限均不变。
保护继承（protected）：派生类继承基类的公有成员和访问成员，这些成员在派生类中的访问权限均变成protected。
私有继承（private）：派生类继承基类的公有成员和访问成员，这些成员在派生类中的访问权限均变成private。

无论是哪种继承，派生类都不继承基类的私有成员，也不能直接访问基类的私有成员，除非通过基类的公有或保护成员函数来访问。

友元函数由于并不是类的成员函数，因此并不参与继承。派生类无法使用基类的友元函数，派生类的友元函数也无法访问基类的成员。

友元类中的友元关系同样无法继承。简单来说，友元关系是一对一的，友元关系中任何一方的基类或派生类都不能继承友元关系。假设有如下关系：
```cpp
class A {
    friend class B; // B是A的友元类
private:
    int value;
};

class B {
public:
    void show(const A & a) {
        cout << a.value;
    }
};
```
B的基类或派生类不是A的友元类，无法在类的声明中访问A的成员。同理，B也不能在类的声明中访问A的基类或派生类成员

## 保护成员
类中可以定义保护成员（protected），对于类外的访问，protected成员与private一样不可访问。

假设基类中声明了一个保护成员，那么在派生类中是可以直接访问该保护成员（因为该保护成员被继承到派生类中），但在基类与派生类之外，该保护成员依旧不能直接访问。


## 创建派生类的对象
1. 首先创建基类对象；
2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
3. 派生类构造函数应初始化派生类新增的数据成员。

举个例子，假设有如下两个类：
```cpp
class Fruit{
private:
    string name;
public:
    Fruit(string s);
    virtual void show();
};

class Apple: public Fruit {
private:
    double weight;
public:
    Apple(string s, double t);
    virtual void show();
};

Fruit::Fruit(string s): name(s) {}

Apple::Apple(string s, double t): Fruit(s), weight(t) {}
```
从上面代码可知，派生类构造函数通过成员初始化列表调用了基类的构造函数，在这一过程中，基类对象首先被构造出来，然后是派生类对象。

一个类也只继承其直接基类的构造函数，不继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将隐式定义它们。

## 多态公有继承
### 重写基类的函数
公有继承的前提下，派生类可以使用基类的成员函数，但如果派生类需要重写该成员函数，则需要基类将对应函数定义为虚函数（成员函数前加上“virtual”关键字），例如上面的show函数，两个类都对该函数进行了定义。

如果要重写基类的成员函数，首先基类的被重写的函数必须是虚函数；其次派生类在重写基类的虚函数时，必须保证函数名与形参表一致，否则派生类写的就是一个新函数，并没有起到重写基类函数的作用。因此，派生类可以在要重写的函数声明后加上“override”关键字，如果重写的函数参数表与基类有出入，或者函数名写错，编译器会报错（“override”相当于多加一层保险，保证基类的虚函数被派生类重写）。
```cpp
class Apple: public Fruit {
public:
    virtual void show() override;
};
```
如果不希望派生类重写基类的虚函数，可以在基类的虚函数声明后加上final关键字。如果有派生类重写该虚函数，则编译器会报错。
```cpp
class Fruit{
public:
    virtual void show() final;
};
```

### 成员寻找机制

当一个对象调用某个成员，编译器会根据成员名开始递归查找。首先编译器会从对象的类声明中查找是否有同名的成员，如果找不到，则从基类的声明中递归查找，直到找到同名成员。

当找到同名成员后，编译器停止递归，检查参数表等是否匹配，如果不匹配编译器也不会继续查找同名成员了，而是直接报错。如果找到的同名成员是虚函数，编译器会再根据实际情况来确定实际要执行的函数版本。


### 基类指针或引用带来的动态绑定
基类指针可直接指向派生类对象；基类引用也可直接引用派生类对象。反过来则不行。因此，现在要在某个普通函数中调用show，参数就必须为基类指针或引用：
```cpp
void print(Fruit & p) {
    p.show();
}
```
如果基类和派生类都不使用虚函数，而是都将show定义成自己的普通成员函数，那么通过对象调用成员函数时，编译器会从对应类的声明中寻找同名成员，也可以起到类似“重写”的效果。但在print中，无论形参指向的是什么类型的对象，都会调用Fruit类的show（因为形参自身是Fruit类型的，编译器默认从Fruit的声明中开始寻找同名成员）。

一般来说，编译时就能令编译器绑定要执行的函数版本，称为静态绑定；代码运行时才能绑定要执行的函数版本，称为动态绑定。像上面真正执行的的show()函数版本只有在运行到print函数时，根据形参p实际指向的对象类型才能绑定，这种称为动态绑定。如果有一个Apple类型的对象直接调用自己的成员函数show，在编译时就能确定show的版本，就是静态绑定。

当然，也可以使用类作用域运算符强制指定要执行的函数版本，在这种情况下函数为静态绑定，并强制编译器从指定类的声明中开始寻找同名函数。
```cpp
//无论形参指向的是什么类型的对象，统一调用Fruit版本的函数
void print(Fruit & p) {
    p.Fruit::show(); 
}
```

### 虚析构函数
基类应将自己的析构函数定义为虚函数，从而允许派生类重写；这是由于考虑到delete一个基类指针时，如果该指针指向的是派生类，那么对一个派生类执行基类的析构函数会导致不可预料的错误。


## 纯虚函数与抽象类

继承让派生类与其基类有了“is-a”关系。但如果要想Java的interface一样，强制让类实现某种接口（即“has-a”关系），可以使用纯虚函数与抽象类。

纯虚函数的声明：虚函数的声明后加上“=0”。声明了纯虚函数，或者父类有纯虚函数但自己并没有重写的类都称为抽象类，抽象类不能实例化对象。

因此，如果要某个类A强行实现某个接口，可以将这个接口定义为纯虚函数（假设该纯虚函数所在的抽象类称为B）。这样一来，让B作为A的派生类，B就必须要重写接口，否则B也成为抽象类，就不能实例化对象。
```cpp
class Abs {
public:
    virtual void func() = 0; 
}; //纯虚函数只需声明，无需定义

class A : public Abs {
public:
    virtual void func();
};
//类A必须重写func函数，否则A无法实例化对象
void A::func() {
    cout << 'A';
}
```