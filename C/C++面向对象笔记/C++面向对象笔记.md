# 类的成员
## 类的内联函数

类的成员函数，如果其定义位于类声明之中，则该函数默认为内联函数。

若要令类声明之外的成员函数也成为内联函数，加入“inline”关键字：
```cpp
inline void Stock::set_tot() {
    ...
}
```
## 构造函数
### 定义与声明
```cpp
类名(参数);    //声明

类名::类名(参数) { //定义
    ...
}
```
同一个类下可定义多个不同参数表的构造函数，调用时会根据传参自动选择对应版本的构造函数。

如果用户没有定义任何构造函数，则编译器会隐式定义一个无任何参数的构造函数（这种称为默认构造函数），而且该函数中不作任何操作：
```cpp
类名::类名() {}
```
如果用户定义了某种构造函数，但没有定义默认构造函数，则在声明一个对象且无初始化时会报错。
### 构造函数调用
以下均可调用构造函数进行初始化：
```cpp
类名 对象名;      //调用默认构造函数，若无定义默认构造函数，该语句报错

类名 对象名(参数);

类名 对象名 = 构造函数名(参数);

// 由于在使用构造函数构造对象之前，对象是不存在的，因此不可通过以下方式调用构造函数：
对象名.构造函数();
```
一般```类名 对象名(参数);```的构造效率要比```类名 对象名 = 构造函数名(参数);```更高，这是由于后者涉及到赋值，可能导致编译器创建一个临时对象后，调用析构函数，再将该临时对象赋值给我们需要的目标对象。

C++11支持对类的列表初始化（只要大括号中的参数与某个构造函数的参数表匹配即可）：
```cpp
类名 对象名 {参数};
```

类也可以作为数组的基本类型，同样支持列表初始化，未被初始化的数组元素将调用默认构造函数：
```cpp
class Stock{
    ...
};
//调用不同的构造函数来初始化数组元素，a[3]未通过列表初始化，将调用默认构造函数
Stock a[4] {Stock(1), Stock(2,3), Stock()}; 
```

## 析构函数
一般来说析构函数无需特意编写，令编译器隐式生成即可。若要自行定义，则：
```cpp
~类名();          //析构函数声明

类名::~类名() {   //析构函数定义
    ... 
}
```
通常不应显式调用析构函数，令编译器自行决定即可（编译器一般在程序结束时调用析构函数，函数里面的操作也会被执行。但通过new生成的对象，编译器一般不会自动调用析构函数，需要手动操作）。

## const成员函数
若某个成员函数不会修改对象的任何成员，则可以将该成员函数定义为const成员函数：
```cpp
返回值类型  函数名(参数) const;           //const成员函数声明

返回值类型  类名::函数名(参数) const {    //const成员函数定义
    ...
}
```
若某个对象被定义为const，则可以直接调用该对象的const成员函数，但调用普通成员函数则会报错（因为编译器无法保证这些函数不会修改其成员）。


## this指针
在类的构造函数、析构函数及成员函数中，若要表示对象本身，可使用关键字“this”。this是一个指针，指向该函数所属对象的地址。

this指针隐式地作为所有非静态成员函数的首个参数。举个例子：
```cpp
class People {
public:
    int age;
    string name;
    bool FindPeople(string s) {
        ...
    }
}
```
实际上FindPeople函数的参数表为：
```cpp
bool FindPeople(People * const this, string s) 
```

而在成员函数中要调用某个成员，表面上我们通过成员名即可调用，实际上通过“this->成员名”方式调用。
<br/><br/>