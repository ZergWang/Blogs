# 静态数据
## 静态数据类型分类
### 局部静态变量
定义在函数内或代码块中，有static关键字修饰的变量。此类变量的作用域仅局限于函数内或代码块中（无链接性）。但变量的内存空间直到程序结束才被回收，因此无论何时进入函数或代码块中，变量仍可继续使用。

### 全局静态变量
全局静态变量定义在函数外，可细分为两种。有static修饰的全局静态变量仅有内部链接型，在整个编译单元（简单来说就是当前cpp源文件中）中均可见。无static修饰的全局静态变量有外部链接性，可在其他编译单元中调用（简单来说就是跨文件调用）。

在跨编译单元调用变量时，C++遵循“单定义规则”，即一个变量只能定义在一个编译单元中，且只能有一次定义，在其他文件中要使用这个变量，使用前必须用“extern”关键字声明且不能初始化该变量。“extern”关键字声明了这个变量是从别的编译单元中“借调”过来的，而不是定义了一个新的变量。

例如，假设在a.cpp中定义了变量a。如果要在b.cpp中使用a，则必须：
```cpp
#include "a.cpp"
extern int a;  //这里不能初始化a，否则会被认为是重新定义了变量a，违反了“单定义规则”
```
extern声明可以看作是对外部变量的引用，不会额外分配存储空间。

### 静态函数
声明在类外的普通函数也可使用static关键字声明。默认状态下（也就是无static修饰的函数）有外部链接性，可以跨编译单元调用。使用static声明后函数就仅有内部链接型，无法跨编译单元调用。

### 与类有关的静态数据类型

类的对象本身也可以声明为静态，其性质与普通的静态变量一致。此外，类的静态成员和静态成员函数可见本人《C++面向对象：类的成员》一文，此处不再赘述。

类的静态成员，其性质、内存分配、初始化时期、作用域以及链接性等特性大致与全局静态变量相同。

## 静态变量初始化
静态变量的内存分配和初始化并不一定是同时进行的。

静态变量的内存分配，在源文件编译时就已经确定，相关的内存结构会被硬编码到可执行文件中。

静态变量的初始化，根据其初始化的具体情况，可以分为**编译期初始化**和**运行期初始化**两种。如果在编译期间，静态变量初始化的值就能确定，则采用编译期初始化，变量会被分配在.data段存储。如果编译期间无法确定静态变量初始化的值，则采用运行期初始化（程序运行时再进行初始化），此类变量会被存储在.bss段。

由于存储在.data段的静态变量在编译期就已经初始化完毕，因此这些初始化的值也会被硬编码到可执行文件中。当执行可执行文件时，.data以及.text段的相关内存结构会直接从可执行文件中加载到对应的内存区域。但.bss段的内存在程序运行后还需要额外的初始化工作。

### 编译期初始化
具体来说，使用.rodata段的数据、字面量或者两者混合的表达式初始化的静态变量，其初始化的值都能在编译期间确定或计算出来。**但有一个例外，初始化为0（无论是字面量0，表达式结果为0）的静态变量使用运行期初始化。**

编译期初始化的静态变量会存储到.data段中。例如下面的a、b、c、d都是静态变量，都在编译期初始化，存储在.data段中。
```cpp
const int constData = 10;
static int a = 2;
static int b = 2 + 3;
int c = constData;
void F() {
    static int d = constData * 2 + 3;
}
```
编译期初始化的静态变量，其初始化顺序和其在内存中的位置一致。例如a存储在最低内存地址处，d存储在最高内存地址处。

### 运行时初始化
当编译期无法确定静态变量初始化的值，则变量的初始化会推迟到程序执行到该变量的声明时才执行。这种称为运行时初始化，静态变量会存储在.bss段中。运行时初始化又可以分成两种情况：
- 初始化为0：没有显式初始化的静态变量，以及显式初始化为字面量0的变量，其对应的内存数据会在main执行前清零。
- 初始化不为0：使用除了.rodata段之外的数据初始化。例如，使用其他静态变量或者函数返回值初始化，则初始化时会执行相应操作。

例如，静态变量a、b、c、d、e都采用运行时初始化，存储在.bss段：
```cpp
static int z0 = 2;
static int a = z0;
static short b;
int c = GetValue();
int d = c;
void F() {
    static int e = 0;
}
```

值得注意的是，全局静态变量的初始化一般在main函数执行前进行（这也被称为**加载时初始化**），局部静态变量的初始化在第一次执行该变量的声明时进行：
```cpp
#include <iostream>
using namespace std;

class A{
public:
    A() { cout << "create A" << endl; }
};

static A a1;

void F() {
    cout << "start function" << endl;
    static A a2;
}

int main() {
    cout << "start main" << endl;
    F();
}
```
上述代码的输出为：
```
create A
start main
start function
create A
```
## 初始化的线程安全问题
在编译期完成初始化的静态变量，以及在main函数执行前初始化（即加载期初始化）的静态变量都是线程安全的。

采用运行期初始化的局部静态变量的值在程序首次执行到其声明时会初始化，之后如果再执行到该语句则跳过，从而保证每次程序运行时局部静态变量最多被初始化一次。在C++中，这一机制通过在内存中为该局部静态变量额外分配一个标志位来实现。该标志位初始为0。当程序运行到静态变量声明语句时，若标志位为0，则初始化变量，同时标志位置为1；若标志位已经为1，则跳过相应语句。但上述初始化过程在多线程环境中可能带来线程冲突的问题。C++11标准规定了其初始化需要保证线程安全。因此在C++11及之后的标准，局部静态变量的初始化会默认采用锁机制保证线程安全。线程在执行局部静态变量的声明语句时，必须先检查锁。无锁的情况下才会依次上锁、检查标志位、（初始化并更改标志位）、解锁。若有锁，则线程阻塞。

<br/><br/>

# 常量



# 参考资料
[局部静态变量是如何做到只初始化一次的?](https://www.cnblogs.com/xuxm2007/p/4652944.html)

