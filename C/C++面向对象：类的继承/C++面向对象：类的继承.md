
# 继承与友元
## 继承方式
```cpp
class 派生类名 : public 基类名 { //公有继承
    ...
};
```
公有继承（public）：派生类继承基类的公有成员和保护成员，这些成员的访问权限均不变。
保护继承（protected）：派生类继承基类的公有成员和保护成员，这些成员在派生类中的访问权限均变成protected。
私有继承（private）：派生类继承基类的公有成员和保护成员，这些成员在派生类中的访问权限均变成private。

无论是哪种继承，派生类也会继承基类的私有成员，但派生类的对象以及派生类内均不能访问基类的私有成员，除非通过基类的公有或保护成员函数来访问。

## 保护成员
类中可以定义保护成员（protected），对于类外的访问，protected成员与private一样不可访问。

假设基类中声明了一个保护成员，那么在派生类中是可以直接访问该保护成员（因为该保护成员被继承到派生类中），但在基类与派生类之外，该保护成员依旧不能直接访问。

## 友元类与友元函数

友元函数由于并不是类的成员函数，因此并不参与继承。派生类无法使用基类的友元函数，派生类的友元函数也无法访问基类的成员。

友元类中的友元关系同样无法继承。简单来说，友元关系是一对一的，友元关系中任何一方的基类或派生类都不能继承友元关系。假设有如下关系：
```cpp
class A {
    friend class B; // B是A的友元类
private:
    int value;
};

class B {
public:
    void show(const A & a) {
        cout << a.value;
    }
};
```
B的基类或派生类不是A的友元类，无法在类的声明中访问A的成员。同理，B也不能在类的声明中访问A的基类或派生类成员。

另外，友元关系同时也是单向的，B是A的友元类，B可以访问A的私有成员，但是反过来A不是B的友元类，A不能访问B的私有成员。


## 派生类对象的构造

在构造派生类对象的过程中，首先会构造出其基类的对象，然后基于基类对象构造出派生类对象，并初始化派生类新增的数据成员。

在派生类的构造函数中，如果显式指定了基类的构造函数（例如通过成员初始化列表），则会使用指定的基类的构造函数，否则会调用基类的默认构造函数。
```cpp
class B: public A { //假设类A有成员k1
    int k2;
public:
    B(int t1, int t2): A(t1), k2(t2) {} // 显式指定基类的构造函数
};
```
如果基类只定义了非默认构造函数，那么，即使派生类定义了默认构造函数，使用该函数构造派生类对象也会报错。

## 派生类对象的析构

派生类对象被析构时，首先会析构派生类对象，然后析构其基类对象。

<br/><br/>

# 多态
## 虚函数
公有继承的前提下，派生类可以使用基类的成员函数，但如果派生类需要重写该成员函数，则需要基类将对应函数定义为虚函数（成员函数前加上“virtual”关键字），例如上面的show函数，两个类都对该函数进行了定义。

如果要重写基类的成员函数，首先基类的被重写的函数必须是虚函数；其次派生类在重写基类的虚函数时，必须保证函数名以及形参表均一致，否则派生类写的就是一个新函数，并没有起到重写基类虚函数的作用。因此，派生类可以在要重写的函数声明后加上“override”关键字，如果重写的函数参数表与基类有出入，或者函数名写错，编译器会报错（“override”相当于多加一层保险，保证基类的虚函数被派生类重写）。
```cpp
class Apple: public Fruit {
public:
    virtual void show() override;
};
```

### final关键字

如果希望派生类只继承基类的虚函数，而不重写，可以在基类的虚函数声明后加上final关键字。如果派生类重写该虚函数，编译器会报错。
```cpp
class Fruit{
public:
    virtual void show() final;
};
```
此外，final还可用于禁止某个类被继承。例如，下面的代码就禁止其他类继承自Fruit类。
```cpp
class Fruit final{
     ...
}
```

## 纯虚函数与抽象类

继承让派生类与其基类有了“is-a”关系。但如果要想Java的interface一样，强制让类实现某种接口（即“has-a”关系），可以使用纯虚函数与抽象类。

纯虚函数的声明：虚函数的声明后加上“=0”。声明了纯虚函数，或者父类有纯虚函数但自己并没有重写的类都称为抽象类，抽象类不能实例化对象。

因此，如果要某个类B强行实现某个接口，可以将这个接口定义为纯虚函数（假设该纯虚函数所在的抽象类称为A）。这样一来，让B作为A的派生类，B就必须要重写接口，否则B也成为抽象类，就不能实例化对象。
```cpp
class A {
public:
    virtual void func() = 0; 
}; //纯虚函数只需声明，无需定义

class B : public A {
public:
    virtual void func();
};

void B::func() {
    //类B必须重写func函数，否则无法实例化对象
}
```

## 虚函数表（虚表）
当要调用某个对象的虚成员函数时，编译器如何知道具体执行基类的版本还是派生类的版本呢？此时通过虚函数表（简称虚表）的机制来确定。
### 虚表的构成
每一个含有虚函数的类都会有其对应的虚表。虚表是一个指针数组，每个指针指向的该类中的某个虚函数。虚表在编译时就构造好，存储在内存的常量区中。

```cpp
class A {
public:
    virtual void f1();
    virtual void f2();
    void f3();
};
```
如上所示，类A的虚表是一个含两个元素的数组，第一个元素指向f1，第二个元素指向f2。虚表不处理普通成员函数。

### 虚表的继承

当派生类继承了含有虚函数的基类，派生类的虚表中也会有指向基类虚函数的指针。如果派生类重写了某个虚函数，则虚表中对应的指针会被指向派生类虚函数的指针覆盖。另外，如果派生类新添加了自己的虚函数，则虚表中也追加对应的指针。

```cpp
class B : public A {
public:
    virtual void f1();
    virtual void f3();
};

class C: public B {
public:
    virtual void f2();
};
```
| 类A的虚表| 类B的虚表| 类C的虚表
|--| -- | -- |
|A::f1()| B::f1()| B::f1()|
|A::f2()| A::f2()| C::f2()|
|     | B::f3()| B::f3() |
 
以类B为例，B继承了A，则B的虚表中会有两个指向A的虚函数的指针。但是由于B重写了f1，则原来指向A::f1的指针被指向B::f1的指针覆盖掉了。另外B新增了自己的虚函数f3，因此虚表中也相应追加一个指针。

### 动态绑定

当含有虚函数的类实例化出对象后，存储对象的内存空间的首位会存储该对象的虚表指针，该指针指向对象所属类的虚表。当通过该对象调用虚函数时，虚表指针就会在指向的虚表中查找同名函数并执行。

编译时就能令编译器确定要执行的函数版本，称为静态绑定；代码运行时才能确定要执行的函数版本，称为动态绑定。C++允许基类指针指向派生类对象；基类引用也可直接引用派生类对象。反过来则不行。如果通过基类指针或引用调用虚函数，则会进行动态绑定。这是由于编译器并不知道基类指针或引用指向的是一个基类对象还是派生类对象，只有在运行时，通过该对象内存地址首位的虚表指针调用到具体函数上才能确定。

```cpp
void print(Fruit & p) {
    p.show();
}
```
通过指针p调用虚函数show，根据虚表的机制，编译器先从p指向的内存中找到对象的虚表指针，然后根据该指针指向的虚表来执行对应版本的虚函数。即使指针p指向的是派生类（Apple）对象，也可以精确地执行Apple::show()。

如果通过基类指针或引用调用普通函数（非虚函数），则必定执行基类的函数版本。这一过程通过静态绑定实现。

如果通过对象或类作用域运算符调用函数，无论被调用函数是否为虚函数都执行静态绑定。编译器会根据调用的对象所属的类中寻找函数。例如，下面使用类作用域运算符强制指定要执行的函数版本，在这种情况下函数为静态绑定，并强制编译器从指定类的声明中开始寻找同名函数。
```cpp
//无论形参指向的是什么类型的对象，统一调用Fruit版本的函数
void print(Fruit & p) {
    p.Fruit::show(); 
}
```

## 成员与普通成员函数的寻找机制

虚表机制不适用于普通成员函数的调用。当一个对象调用某个成员函数，编译器会根据成员函数名开始递归查找。首先编译器会从该对象的类声明中查找是否有同名的成员函数，如果找不到，则从其基类的声明开始，向上递归查找，直到找到同名成员函数。

当找到同名成员函数后，编译器停止递归，检查参数表等是否匹配，如果不匹配编译器也不会继续向上递归寻找了，而是直接报错。

综上，假设基类和派生类分别有同名的普通成员。如果通过基类指针调用成员，即使指针指向的是派生类对象，调用的永远是基类的成员。


## 构造函数的多态

构造函数不能是虚函数，这是由于构造函数在对象还未完全构造好之前就被调用，此时对象的虚表指针也尚未确定，构造函数也就无法通过虚表来调用。

如果需要在构造函数中实现多态，可以考虑使用工厂模式来创建对象。

## 析构函数的多态
基类应将自己的析构函数定义为虚函数，从而允许派生类重写；这是由于考虑到delete一个基类指针时，如果该指针指向的是派生类，那么对一个派生类执行基类的析构函数会导致不可预料的错误。

<br/><br/>

# 多重继承

一个类可以同时继承自多个基类：
```cpp
class 派生类名: public 基类A, protected 基类B {
    ...
};
```
多重继承时，对于不同的基类可以使用不同的继承方式，例如上面的派生类公有继承了A，保护继承了类B。

## 多重继承的内存布局
如果某个派生类继承了多个基类，该派生类对象的内存地址中，按继承顺序存储各个基类的成员。

```cpp
class D: public A, public B, public C ... {
    ...
};
```
如上所示，则D的对象的内存布局为：
|D对象的内存布局|
| --- |
| A的虚表指针及成员|
| B的虚表指针及成员|
| C的虚表指针的成员|
| ... |

对于多重继承中的虚表指针，有多少个基类存在虚函数表，派生类对象就会有多少个虚表指针。虚函数的继承分成如下三种情况：

- 基类中没有，派生类中特有的虚函数：这些虚函数会追加在派生类继承的首个基类的虚表中。例如，假设D类中有个特有的虚函数，该虚函数会

## 多重继承的指针类型转换


## 多重继承时的构造与析构
派生类在构造时，可以使用成员初始化列表同时构造多个基类。例如在编写类D的构造函数时：
```cpp
D(): A(参数), B(参数), C(参数) {
    ...
}
```
多个基类的构造函数在成员初始化列表中的调用顺序可以随意，不影响基类成员的实际构造顺序。

在构造顺序上，会先按照派生类继承时的顺序依次构造基类对象，最后再构造派生类对象。析构顺序则与构造顺序完全相反。例如，对于上面D的对象，构造顺序是 A -> B -> C -> D。析构顺序为 D -> C -> B -> A。


<br/><br/>


# 虚继承
## 菱形继承
```cpp
class A {
public:
    int a = 1;
};

class B1: public A {
};

class B2: public A {
};

class C: public B1, public B2 {
};
```
假设类A有两个派生类B1和B2，当有一个类C多重继承自B1和B2时，就会构成菱形继承。C的对象访问A的成员时就会发生二义性错误，因为B1、B2都继承了A的成员，编译器无法确定C的对象访问的成员是从B1中继承的还是从B2中继承的。

要解决上述问题，要么使用类作用域符显式指定是哪一个类的成员：
```cpp
C c;
cout << c.B1::p << end;
```
要么使用虚继承的方式规避二义性错误。

## 虚基类与虚继承
当派生类以虚继承的方式继承自一个基类，该基类就成为了虚基类：
```cpp
class 派生类名: virtual 继承方式 基类名 {
    ...
};
```

当派生类虚继承了一个虚基类后，派生类的内存空间


https://www.cnblogs.com/QG-whz/p/4909359.html