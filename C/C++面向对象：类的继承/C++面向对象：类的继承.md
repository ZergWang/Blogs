
# 继承与友元
## 继承方式
```cpp
class 派生类名 : public 基类名 { //公有继承
    ...
};
```
公有继承（public）：派生类继承基类的公有成员和访问成员，这些成员的访问权限均不变。
保护继承（protected）：派生类继承基类的公有成员和访问成员，这些成员在派生类中的访问权限均变成protected。
私有继承（private）：派生类继承基类的公有成员和访问成员，这些成员在派生类中的访问权限均变成private。

无论是哪种继承，派生类都不继承基类的私有成员，也不能直接访问基类的私有成员，除非通过基类的公有或保护成员函数来访问。

## 保护成员
类中可以定义保护成员（protected），对于类外的访问，protected成员与private一样不可访问。

假设基类中声明了一个保护成员，那么在派生类中是可以直接访问该保护成员（因为该保护成员被继承到派生类中），但在基类与派生类之外，该保护成员依旧不能直接访问。

## 友元类与友元函数

友元函数由于并不是类的成员函数，因此并不参与继承。派生类无法使用基类的友元函数，派生类的友元函数也无法访问基类的成员。

友元类中的友元关系同样无法继承。简单来说，友元关系是一对一的，友元关系中任何一方的基类或派生类都不能继承友元关系。假设有如下关系：
```cpp
class A {
    friend class B; // B是A的友元类
private:
    int value;
};

class B {
public:
    void show(const A & a) {
        cout << a.value;
    }
};
```
B的基类或派生类不是A的友元类，无法在类的声明中访问A的成员。同理，B也不能在类的声明中访问A的基类或派生类成员。

另外，友元关系同时也是单向的，B是A的友元类，B可以访问A的私有成员，但是反过来A不是B的友元类，A不能访问B的私有成员。

<br/><br/>

# 多态
## 构造函数的多态
1. 首先创建基类对象；
2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
3. 派生类构造函数应初始化派生类新增的数据成员。

举个例子，假设有如下两个类：
```cpp
class Fruit{
private:
    string name;
public:
    Fruit(string s);
    virtual void show();
};

class Apple: public Fruit {
private:
    double weight;
public:
    Apple(string s, double t);
    virtual void show();
};

Fruit::Fruit(string s): name(s) {}

Apple::Apple(string s, double t): Fruit(s), weight(t) {}
```
从上面代码可知，派生类构造函数通过成员初始化列表调用了基类的构造函数，在这一过程中，基类对象首先被构造出来，然后是派生类对象。

一个类只继承其直接基类的构造函数，不继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将隐式定义它们。


## 虚函数
公有继承的前提下，派生类可以使用基类的成员函数，但如果派生类需要重写该成员函数，则需要基类将对应函数定义为虚函数（成员函数前加上“virtual”关键字），例如上面的show函数，两个类都对该函数进行了定义。

如果要重写基类的成员函数，首先基类的被重写的函数必须是虚函数；其次派生类在重写基类的虚函数时，必须保证函数名与形参表一致，否则派生类写的就是一个新函数，并没有起到重写基类函数的作用。因此，派生类可以在要重写的函数声明后加上“override”关键字，如果重写的函数参数表与基类有出入，或者函数名写错，编译器会报错（“override”相当于多加一层保险，保证基类的虚函数被派生类重写）。
```cpp
class Apple: public Fruit {
public:
    virtual void show() override;
};
```
如果不希望派生类重写基类的虚函数，可以在基类的虚函数声明后加上final关键字。如果有派生类重写该虚函数，则编译器会报错。
```cpp
class Fruit{
public:
    virtual void show() final;
};
```

## 成员寻找机制

当一个对象调用某个成员，编译器会根据成员名开始递归查找。首先编译器会从对象的类声明中查找是否有同名的成员，如果找不到，则从基类的声明中递归查找，直到找到同名成员。

当找到同名成员后，编译器停止递归，检查参数表等是否匹配，如果不匹配编译器也不会继续查找同名成员了，而是直接报错。如果找到的同名成员是虚函数，编译器会再根据实际情况来确定实际要执行的函数版本。


## 基类指针或引用带来的动态绑定
基类指针可直接指向派生类对象；基类引用也可直接引用派生类对象。反过来则不行。因此，现在要在某个普通函数中调用show，参数就必须为基类指针或引用：
```cpp
void print(Fruit & p) {
    p.show();
}
```
如果基类和派生类都不使用虚函数，而是都将show定义成自己的普通成员函数，那么通过对象调用成员函数时，编译器会从对应类的声明中寻找同名成员，也可以起到类似“重写”的效果。但在print中，无论形参指向的是什么类型的对象，都会调用Fruit类的show（因为形参自身是Fruit类型的，编译器默认从Fruit的声明中开始寻找同名成员）。

一般来说，编译时就能令编译器绑定要执行的函数版本，称为静态绑定；代码运行时才能绑定要执行的函数版本，称为动态绑定。像上面真正执行的的show()函数版本只有在运行到print函数时，根据形参p实际指向的对象类型才能绑定，这种称为动态绑定。如果有一个Apple类型的对象直接调用自己的成员函数show，在编译时就能确定show的版本，就是静态绑定。

当然，也可以使用类作用域运算符强制指定要执行的函数版本，在这种情况下函数为静态绑定，并强制编译器从指定类的声明中开始寻找同名函数。
```cpp
//无论形参指向的是什么类型的对象，统一调用Fruit版本的函数
void print(Fruit & p) {
    p.Fruit::show(); 
}
```

## 析构函数的多态
基类应将自己的析构函数定义为虚函数，从而允许派生类重写；这是由于考虑到delete一个基类指针时，如果该指针指向的是派生类，那么对一个派生类执行基类的析构函数会导致不可预料的错误。


## 纯虚函数与抽象类

继承让派生类与其基类有了“is-a”关系。但如果要想Java的interface一样，强制让类实现某种接口（即“has-a”关系），可以使用纯虚函数与抽象类。

纯虚函数的声明：虚函数的声明后加上“=0”。声明了纯虚函数，或者父类有纯虚函数但自己并没有重写的类都称为抽象类，抽象类不能实例化对象。

因此，如果要某个类A强行实现某个接口，可以将这个接口定义为纯虚函数（假设该纯虚函数所在的抽象类称为B）。这样一来，让B作为A的派生类，B就必须要重写接口，否则B也成为抽象类，就不能实例化对象。
```cpp
class Abs {
public:
    virtual void func() = 0; 
}; //纯虚函数只需声明，无需定义

class A : public Abs {
public:
    virtual void func();
};
//类A必须重写func函数，否则A无法实例化对象
void A::func() {
    cout << 'A';
}
```