
# 继承与友元
## 继承方式
```cpp
class 派生类名 : public 基类名 { //公有继承
    ...
};
```
公有继承（public）：派生类继承基类的公有成员和访问成员，这些成员的访问权限均不变。
保护继承（protected）：派生类继承基类的公有成员和访问成员，这些成员在派生类中的访问权限均变成protected。
私有继承（private）：派生类继承基类的公有成员和访问成员，这些成员在派生类中的访问权限均变成private。

无论是哪种继承，派生类都不继承基类的私有成员，也不能直接访问基类的私有成员，除非通过基类的公有或保护成员函数来访问。

## 保护成员
类中可以定义保护成员（protected），对于类外的访问，protected成员与private一样不可访问。

假设基类中声明了一个保护成员，那么在派生类中是可以直接访问该保护成员（因为该保护成员被继承到派生类中），但在基类与派生类之外，该保护成员依旧不能直接访问。

## 友元类与友元函数

友元函数由于并不是类的成员函数，因此并不参与继承。派生类无法使用基类的友元函数，派生类的友元函数也无法访问基类的成员。

友元类中的友元关系同样无法继承。简单来说，友元关系是一对一的，友元关系中任何一方的基类或派生类都不能继承友元关系。假设有如下关系：
```cpp
class A {
    friend class B; // B是A的友元类
private:
    int value;
};

class B {
public:
    void show(const A & a) {
        cout << a.value;
    }
};
```
B的基类或派生类不是A的友元类，无法在类的声明中访问A的成员。同理，B也不能在类的声明中访问A的基类或派生类成员。

另外，友元关系同时也是单向的，B是A的友元类，B可以访问A的私有成员，但是反过来A不是B的友元类，A不能访问B的私有成员。

<br/><br/>

# 多态
## 虚函数
公有继承的前提下，派生类可以使用基类的成员函数，但如果派生类需要重写该成员函数，则需要基类将对应函数定义为虚函数（成员函数前加上“virtual”关键字），例如上面的show函数，两个类都对该函数进行了定义。

如果要重写基类的成员函数，首先基类的被重写的函数必须是虚函数；其次派生类在重写基类的虚函数时，必须保证函数名与形参表一致，否则派生类写的就是一个新函数，并没有起到重写基类函数的作用。因此，派生类可以在要重写的函数声明后加上“override”关键字，如果重写的函数参数表与基类有出入，或者函数名写错，编译器会报错（“override”相当于多加一层保险，保证基类的虚函数被派生类重写）。
```cpp
class Apple: public Fruit {
public:
    virtual void show() override;
};
```
如果不希望派生类重写基类的虚函数，可以在基类的虚函数声明后加上final关键字。如果有派生类重写该虚函数，则编译器会报错。
```cpp
class Fruit{
public:
    virtual void show() final;
};
```

## 纯虚函数与抽象类

继承让派生类与其基类有了“is-a”关系。但如果要想Java的interface一样，强制让类实现某种接口（即“has-a”关系），可以使用纯虚函数与抽象类。

纯虚函数的声明：虚函数的声明后加上“=0”。声明了纯虚函数，或者父类有纯虚函数但自己并没有重写的类都称为抽象类，抽象类不能实例化对象。

因此，如果要某个类B强行实现某个接口，可以将这个接口定义为纯虚函数（假设该纯虚函数所在的抽象类称为A）。这样一来，让B作为A的派生类，B就必须要重写接口，否则B也成为抽象类，就不能实例化对象。
```cpp
class A {
public:
    virtual void func() = 0; 
}; //纯虚函数只需声明，无需定义

class B : public A {
public:
    virtual void func();
};

void B::func() {
    //类B必须重写func函数，否则无法实例化对象
}
```

## 虚函数表（虚表）
当要调用某个对象的虚成员函数时，编译器如何知道具体执行基类的版本还是派生类的版本呢？此时通过虚函数表（简称虚表）的机制来确定。
### 虚表的构成
每一个含有虚函数的类都会有其对应的虚表。虚表是一个指针数组，每个指针指向的该类中的某个虚函数。虚表在编译时就构造好，存储在内存的常量区中。

```cpp
class A {
public:
    virtual void f1();
    virtual void f2();
    void f3();
};
```
如上所示，类A的虚表是一个含两个元素的数组，第一个元素指向f1，第二个元素指向f2。虚表不处理普通成员函数。

### 虚表的继承

当派生类继承了含有虚函数的基类，派生类的虚表中也会有指向基类虚函数的指针。如果派生类重写了某个虚函数，则虚表中对应的指针会被指向派生类虚函数的指针覆盖。另外，如果派生类新添加了自己的虚函数，则虚表中也追加对应的指针。

```cpp
class B : public A {
public:
    virtual void f1();
    virtual void f3();
};

class C: public B {
public:
    virtual void f2();
};
```
| 类A的虚表| 类B的虚表| 类C的虚表
|--| -- | -- |
|A::f1()| B::f1()| B::f1()|
|A::f2()| A::f2()| C::f2()|
|     | B::f3()| B::f3() |
 
以类B为例，B继承了A，则B的虚表中会有两个指向A的虚函数的指针。但是由于B重写了f1，则原来指向A::f1的指针被指向B::f1的指针覆盖掉了。另外B新增了自己的虚函数f3，因此虚表中也相应追加一个指针。

### 动态绑定

当含有虚函数的类实例化出对象后，存储对象成员的内存中会额外分配一个空间存储该对象的虚表指针，该指针指向对象所属类的虚表。当通过该对象调用虚函数时，虚表指针就会在指向的虚表中查找同名函数并执行。

编译时就能令编译器确定要执行的函数版本，称为静态绑定；代码运行时才能确定要执行的函数版本，称为动态绑定。虚表的机制就是一种动态绑定，因为直到对象调用虚函数时，才能从虚表中确定要执行的函数版本。

C++允许基类指针指向派生类对象；基类引用也可直接引用派生类对象。反过来则不行。根据这一特性，我们可以使用基类指针或引用来实现多态：
```cpp
void print(Fruit & p) {
    p.show();
}
```
通过指针p调用虚函数show，根据虚表的机制，编译器先从p指向的内存中找到对象的虚表指针，然后根据该指针指向的虚表来执行对应版本的虚函数。即使指针p指向的是派生类（Apple）对象，也可以精确地执行Apple::show()。

如果基类和派生类都不使用虚函数，而是都将show定义成自己的普通成员函数，那么通过对象调用成员函数时，编译器会从对应类的声明中寻找同名成员，也可以起到类似“重写”的效果。但在print中，无论形参指向的是什么类型的对象，都会调用Fruit类的show（因为形参自身是Fruit类型的，编译器默认从Fruit的声明中开始寻找同名成员）。

可以使用类作用域运算符强制指定要执行的函数版本，在这种情况下函数为静态绑定，并强制编译器从指定类的声明中开始寻找同名函数。
```cpp
//无论形参指向的是什么类型的对象，统一调用Fruit版本的函数
void print(Fruit & p) {
    p.Fruit::show(); 
}
```

### 如何寻找普通成员

虚表机制不适用于普通成员的调用。当一个对象调用某个成员，编译器会根据成员名开始递归查找。首先编译器会从该对象的类声明中查找是否有同名的成员，如果找不到，则从其基类的声明开始，向上递归查找，直到找到同名成员。

当找到同名成员后，编译器停止递归，检查参数表等是否匹配，如果不匹配编译器也不会继续向上寻找其他同名成员了，而是直接报错。

综上，假设基类和派生类分别有同名的普通成员。如果通过基类指针调用成员，即使指针指向的是派生类对象，调用的永远是基类的成员。


## 构造函数的多态
1. 首先创建基类对象；
2. 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
3. 派生类构造函数应初始化派生类新增的数据成员。

举个例子，假设有如下两个类：
```cpp
class Fruit{
private:
    string name;
public:
    Fruit(string s);
    virtual void show();
};

class Apple: public Fruit {
private:
    double weight;
public:
    Apple(string s, double t);
    virtual void show();
};

Fruit::Fruit(string s): name(s) {}

Apple::Apple(string s, double t): Fruit(s), weight(t) {}
```
从上面代码可知，派生类构造函数通过成员初始化列表调用了基类的构造函数，在这一过程中，基类对象首先被构造出来，然后是派生类对象。

一个类只继承其直接基类的构造函数，不继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将隐式定义它们。


## 析构函数的多态
基类应将自己的析构函数定义为虚函数，从而允许派生类重写；这是由于考虑到delete一个基类指针时，如果该指针指向的是派生类，那么对一个派生类执行基类的析构函数会导致不可预料的错误。

<br/><br/>

# 虚继承

