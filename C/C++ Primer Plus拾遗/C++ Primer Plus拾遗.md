<font color='ff0000'>**本博文整理了《C++ Primer Plus（第六版）》前九章中的部分知识点，基本为Modern C++（C++11标准）的一些特性。**</font>
<br/>


# C与C++的语言特性
## C语言特性
- 结构化编程（Structured Programming）：早期语言（如 Fortran 和 Basic ）在代码组织上可能会存在问题（例如分支语句常常会让代码逻辑和可读性变得特别差）。对此，C语言使用了结构化编程这一方法，将程序中的分支限制为一组易读的代码结构（例如 for、while、do while 循环以及 if else 语句）。
- 
- 面向过程编程（Procedure Oriented Programming）：以过程为中心的编程思想。以“什么正在发生”为主要目标进行编程
- 自顶向下（ top-down ）：将大型程序分解为多个小型、易管理、可重复调用的小任务，这个分解过程可以持续下去，把小任务分解为更小的任务。在C语言中，通过函数来实现“自顶向下”。

## C++语言特性
- 面向对象编程（Object Oriented Programming）：在 C++ 中通过类与对象这两种数据结构及封装、多态、继承等方法实现。类规定了用何数据描述一个物像（或者概念）并规定了如何用这些数据去描述，对象则是根据类的要求构造的而成的，代表某个物像（或概念）的特殊数据结构。因此与面向过程不同，面向对象的重点不在任务上，而在于表示概念。面向对象编程常常从低级组织（类）开始构建，进而构建高级组织（程序），该过程称为自下向上编程（ bottom-up ）
- 泛型编程（Generic Programming）：泛型也是一种特殊的抽象数据结构，相较于面向对象编程关注于数据，泛型编程关注算法本身，因此其不拘泥于数据类型。例如，写一个两数相加返回结果的函数，若输入的数据类型可能为int，也可能为float，则比较麻烦，通过泛型（更具体地说，使用模板）则可较为方便地解决。

- 强类型语言：C和C++都是强类型语言，所有的变量在声明时必须指定其类型，基于此特性C++11标准中做出了许多规范与改进（如auto、decltype、右值引用等语法）

## 可移植性及C++标准
可移植性是指同样的代码，只需要使用针对不同平台设计的编译器进行编译，而不必更改代码本身，就可以跨平台运行（这里所说的平台，是CPU + 操作系统，也就是说，即使操作系统相同，CPU不同，也可能算作不同平台）。然而程序的可移植性的实现有两大阻碍。一是硬件。例如不同的CPU有不同的指令集，这些指令集所构成的汇编语法在不同CPU上可能大相径庭；二是标准。即使是同样的软硬件条件，同一种编程语言由于标准不同语法上可能会有些许差异。

要解决第二种阻碍，可通过制定针对所有平台的统一标准来实现。对此，ISO标准委员会分别于1998、2003、2011年推出了C++标准（分别为C++98、C++03、C++11标准，其中C++03是C++98的补丁版，两者语言特性一致）。之后也ISO也颁布过C++14、C++17等标准。同理，C语言也有国际标准，如C89、C90、C99等（其中C89和C90一样）
虽然C++一般可以视为功能更强大的C，但两者并不能完全兼容。C++标准可“近似地”视为C标准的超集，但也并不是所有的C语言的代码都可正确运行于C++中。

<font color='ff0000'>**C++ Primer Plus 书中所述基于C++98标准，并介绍部分C++11特性。**</font>
<br/><br/>

# 整型
## 分类
C++中的整型有char、short、int、long、long long五种类型（全名分别为short int、long int、long long int，但一般都简写……），每种类型都有有符号版本和无符号版本，因此总共有10种整型。

为了适应日益繁多的字符类型，C++ 还推出wchar_t 类型，C++ 11 标准还加入了char16_t 和 char 32_t 类型。

按ISO/IEC 14882:2011（即C++ 11标准），无符号类型的char、short、int、long、long long的数据范围都不得低于排在它前面的哪一种数据类型，且标准提到了，具体数据范围可根据环境制定。其中，int型应该为“自然长度”，也就是计算机处理起来效率最高的长度，例如在32位系统中，int就占32位，但在16位系统中，int一般只能占16位。当然也有例外，windows64位环境下，int仍然只占32位。


## 整型字面值
除了十进制，C++支持用八进制和十六进制表示整数。

八进制：第一位为0，第二位为0到7的数字，则从第二位开始到结束的一整串数字表示一个八进制整数，如012，表示的数字十进制下为11。

十六进制：第一位为0，第二位为“x”或“X”，则从第三位开始到结束的一整串数字表示一个十六进制整数（A~F大小写均可）。如0xF，表示十进制数15。

无论用何种表示方法，在cout的时候统一转换成十进制表示。当然也可用格式控制符指定显示以何种进制显示：
```cpp
int a = 0xf;
cout<<hex<<a<<endl;    //16
cout<<dec<<a<<endl;    //10
cout<<oct<<a<<endl;    //8
```
## 常数后缀
数字常量后可用字母后缀定义其类型，其中，对于整数来说，“u”表示无符号，“l”表示long类型，“ll”表示long long类型。其中，这些后缀顺序随意，大小写不影响，举一些例子：
```cpp
65536ull
65536llu
999l
999u
```
后缀体系可以和八进制、十六进制混用。

常数后缀的作用：

1. 帮助auto类型推导。

2. 隐式转换。C++中对于整数数字的处理，如果在int范围内就处理为int型，超出则根据平台情况处理为long或long long类型，在用整数数字进行运算时，一般int与int运算，结果默认也为int型，则就会有以下情况产生：
```cpp
long long b = 2100000000 * 2;
```
系统会报错，虽然相乘的结果没有超出long long范围，但两个乘数默认处理为int型，相乘结果也默认为int型，则就超了。正确写法：

```cpp
long long b = 2100000000ll * 2;
```
<br/><br/>

# 浮点型
分为float（单精度）、double（双精度）、long double三种类型，分别为32、64、128位。（和整型数据类型一样，这三种浮点型实际大小也不是全平台固定的，以上结果为Win10系统下所得）

对于float，十进制下有效数字有7位，double则可以达到15位。

## 浮点型常数表示
可以采用类似科学计数法的方式表示浮点型常数：例如，38.675，可表示为：3.8675e+1（E也可以，大小写不限），e后面是10的指数，若指数为正可省略加号。

另外，可以指定浮点型常数的类型。默认情况下为double型，“f”后缀表示float型，“l”后缀为long double型，大小写不限，且可以和上述的科学计数表示法混用。
```cpp
cout<< 3.0000001f - 3;
cout<< 3.0000001 - 3;
```
前者输出0，后者输出1e-007，这是因为3.0000001被指定为float型后，由于只能保证7位有效数字的精度，最后的1就被舍掉了。
<br/><br/>

# 对数据类型的操作
## 变量命名
变量名由下划线、字母、数字组合而成，其中不可用数字作为开头。单个下划线可作变量名。

下划线打头的变量是合法的，但不建议用户自定义变量采取这种命名方式。因为“_”、“__”开头的多为系统库函数和宏的名称，用户如此命名自己的变量可能会影响运行的稳定性。

## 列表初始化
### 普通变量初始化
```cpp
int a = {5};
```
将a初始化为5，其中，“=”可以省略，如果初始化为0，大括号内可以什么都不填。

该初始化方法适用于几乎全部C++自带数据类型：
```cpp
char c{};
string s{"123"};
```
此外，使用列表初始化，对于变量类型要求更为严格：不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。如：
```cpp
char a {99999};
char b = 99999;
```
对b的初始化只是warning，但对于a的初始化就是error了……

此外还有：
```cpp
int a = 70;
char b {a};
```
运行的时候虽然只是警告，但也需要注意，在初始化b时，由于a是int型，因此很有可能a中的值会超过b的范围。但相反，给一个int型的变量初始化为一个short型变量的值是被允许的。
### 数组初始化
和普通变量初始化一样，“=”可以省略，如果初始化为0，大括号内可以什么都不填。
```cpp
int a[3] {1, 2, 3};
int b[3] {};
```
同样，数组初始化时每个元素都不允许缩窄：
```cpp
int a[3] {1.0, 2, 3};  //错误，int不允许小数
char b[3] {'a', 999, '\0'};   //错误，999超出char型范围
```
对于字符串、字符数组，可：
```cpp
char c[] {"abcd"};
string s {"abcd"};
```
### 结构体初始化
“=”可以省略，大括号内不写东西则全初始化为0，各元素均不得缩窄。
```cpp
struct Student {
    char name[10];
    int age;
    float score;
};

Student s {"Alice", 15, 89.5};
```
<br/>

## 类型转换
当表达式中含有多个不同的数据类型时，会进行整型提升（integral promotion），bool、char、short及其对应无符号型会被统一转换为int型（bool中的true被转换为1，false被转换为0）。但如果表达式中含有long long类型，则不会作进一步提升。（因此最后运算结果如果超出int范围，即使赋值给long long 型，也会出错）

但如果表达式中涉及到浮点型，则会进一步提升到浮点型，并以最大的类型为准进行提升。举个例子（a的赋值会出错而b不会）：
```cpp
long long a = 2 * 2100000000;
long long b = 2.0 * 2100000000;
```
强制类型转换：(类型名)变量名或常量，类型名(变量名或常量)，举个例子：

```cpp
float a = 1.8;
cout<<(int)9.8;
cout<<int(9.8);
cout<<(int)a;
cout<<int(a)
```
输出9，9，1，1。

## auto声明
一种特殊数据类型，可以根据变量所赋初始值推断变量类型。因此，C++11标准规定在定义auto变量的同时必须进行初始化。
```cpp
auto a = 0;     //推断为int型
auto b = 0.0;   //推断为double型
```
<br/><br/>


# 逗号表达式
将多个表达式作为一条语句，常用于for循环之中。
例如：
```cpp
i++, j--;
```
逗号表达式按从左到右运算，即先进行i++，再执行j--。逗号表达式本身也有值，其返回最后执行部分（也就是整个逗号表达式最右边的值），例如：
```cpp
printf("%d\n", (1,2,3));   //输出3
```
<br/><br/>


# C++11中对数组遍历的简单方法：range型循环
对普通数组或vector等的遍历，可：
```cpp
int a[] {1,2,3,4};
for (int i : a)
    cout << i;      //数组输出

for (int &p : a)
    p += 1;         //数组更改

```
<br/><br/>



# const
const关键字一般用于修饰其右边的常量，使该常量的值在运行过程中永远保持其初始化时的值，不被任何操作改变（因此const常量在声明时必须初始化）。此外，const关键字有static的作用，令常量具有内部链接性。

举个例子，```const int a = 3;```，const修饰了a，a变成了常量，a的值不可更改。

## 常量指针与指针常量

### 定义

指向常量的指针，称为常量指针。指针本身可以被修改，但不可通过该指针改变其指向的内容。

一个指针类型的常量，称为指针常量。该指针无法被修改（指向的地址不变），但地址中的内容可以随意修改。

按照const对右边常量的修饰规则，我们可以轻松分辨常量指针和指针常量：
```cpp
const int * p1;        
//常量指针，const修饰了*p1，*p1变成了常量，*p1不可更改，但p1可更改。
int const * p2;  
//也是常量指针      

int * const p3;        
//指针常量，const修饰了p3，p3不可更改，但*p3可更改
const * int p4;
//不合法，*不能放在int左边

const int * const p5;  //其实也是指针常量，但它本身不可被修改，其指向的内容也不可通过该指针进行修改
int const * const p6;  //同p5
```

### 应用
常量指针一般用于通过指针传参时，保护指针指向地址内的值不被修改。而这个被指向的内容本身是不是const，其实无所谓。

例如，保护数组a在函数中不被修改：
```cpp
void PrintArr(const int a[], int n);
```
此时若在函数中更改了数组某元素，编译器会报错。

<br/><br/>


# 函数
## 内联函数
内联函数的作用和宏类似，将调用内联函数的代码替换成函数本身的代码段，以此实现更高的执行效率。

在函数定义前加入“inline”关键字即可定义内联函数。
```cpp
inline double square(double x) { return x*x;}
```

一般高效（代码少，执行快）且频繁调用的函数会被改造为内联函数。实际上，和C语言中的register类似，即使用户将函数定义为内联函数，若函数代码过长，或者函数中存在递归，编译器也不会将其作为内联函数编译。

和宏相比，内联函数在使用上更加方便，也更易理解。尤其在参数传递上更容易规避潜在风险。例如：
```cpp
#define SQUARE(x) x*x

SQUARE(1+2)  //会被替换为 1+2 * 1+2
```
## 默认参数
函数参数可从右向左设置默认值：
```cpp
int Add(int a = 0, int b = 0);
//仅给a设置默认值而不给b设是非法的
//换句话说，如果给某个参数设置了默认值，则该参数右边的所有参数也必须设置默认值
```
在调用Add函数时，传入的实参将按从左到右的顺序赋给形参，若传入的实参不够，形参则会使用默认值：
```cpp
Add(1);   //等价于Add(1, 0)
Add();    //等价于Add(0, 0)
Add(, 1); //错误写法，不可跳过参数
```
## 函数重载
### 原理简介
C++支持函数重载，允许定义名字相同的函数，只要其参数表的特征标不同即可。参数名、返回值类型并不影响对特征标是否相同的判断。对于两个函数的参数表，从左往右对应的每个参数，其中有任何一个类型不同（注意：引用类型与其原类型在函数重载中被视为不同类型），则特征标不同。

函数重载同时也支持默认参数，在调用函数时，会根据实参的类型和数量去匹配对应的函数，若无对应，则会考虑进行类型转换。例如有以下函数：
```cpp
void Add(int* x, int* y);          //函数1
void Add(int x, int y);           //函数2
void Add(double x, int y = 2);//函数3

Add(1, 2.2);//找不到对应函数，则进行类型转换，匹配函数2
Add(3);       //匹配函数3
```
如果类型转换后有多个能匹配到的函数版本，则会报错：
```cpp
void Add(int & x, int & y)      //函数1
void Add(int x, int y)          //函数2
void Add(double x, double y)    //函数3

int a = 1, b = 2;
Add(1.1, 2);   //报错，可匹配函数2或3
Add(a, b);     //报错，可匹配函数1或2
Add(1, 2);     //正确，右值不能匹配引用类型的形参，所以仅匹配函数2
```

### const修饰对函数重载的影响
两个同名函数各仅有一个参数，但一个有const，一个无const，那么它们是否能构成重载呢？这重要取决于const修饰符能否影响对实参的修改。

如果加了const修饰符，函数中对形参的修改不影响实参；没加const，对形参的修改会影响实参，则特征标会认为不相同，构成重载。

```cpp
void F(const int a)
void F(int a) 
//编译不通过，因为有无const都不能影响到实参，两函数的特征标被认为是相同的

void F(const int & a) //对形参的修改无法影响实参
void F(int & a)       //对形参的修改会影响实参
//编译通过，可构成重载

void F(const int * a) //常量指针，在函数中无法通过该指针修改实参
void F(int * a)      
//编译通过，可构成重载

void F(int * const a) //指针常量，不能更改指针本身，但指针指向的地址中的值可变，因此可通过指针修改实参
void F(int * a)      
//编译不通过，有无const，对形参的修改都会影响实参

void F(const int * const a) //常量指针常量，指针本身以及指向的地址中的值都不能更改
void F(int * a)     
//编译通过，可构成重载 
```

## 函数模版
如果需要编辑一个能支持多种类型的参数的函数，我们可以使用函数模板，而无需为每一种类型的参数分别开发一个函数：
```cpp
template <typename T>
//也可以写成template <class T>
void Swap(T & a, T & b) {
    T temp;
    temp = a;
    a = b;
    b =temp;
}
```
程序在执行时，编译器会根据传入参数的类型来自动生成对应版本的函数。

函数模版同样支持重载，编译器会选择对应版本的函数模版执行：
```cpp
template <typename T>
void Swap(T & a, T & b) 

template <typename T>
void Swap(T & a, T & b, T & c) 
```
### 具体化

上面的Swap函数模版适用于int、short、char等类型的实参，但现在有一个自定义的struct类型也需要Swap函数，但只交换其中部分成员的值，此时就可以使用显式具体化，单独为这个类型定制一个Swap函数：
```cpp
//也可以简写为：
//template<> void Swap(MyStruct & a, MyStruct & b) 
template<> void Swap<MyStruct>(MyStruct & a, MyStruct & b) {
    ...
}
```

### 实例化
使用函数模板时，编译器会生成的对应版本的函数，这个“生成”的过程称为实例化。实例化分成隐式实例化和显式实例化两种。隐式实例化就是让编译器根据实参类型自行判断要实例化的函数版本，显式实例化就是用户自行指定要实例化的函数版本：
```cpp
int a = 1, b = 2;
double c = 3, d = 5;

Swap(a, b); //隐式实例化，编译器根据实参类型实例化int型的函数
Swap<double>(c,d) //显式实例化，无需推断，编译器直接实例化double型的函数
```
显式实例化不需要编译器根据实参推导类型，因此效率一般要高于隐式实例化。

如果代码中迟早会使用到某种版本的函数，也可以提前让编译器实例化：
```cpp
//也可以简写为：
//template void Swap(double & a, double & b);
template void Swap<double>(double & a, double & b);
int main() {
    double c = 3, d = 5;
    Swap(c,d);  //double版本的函数已经提前实例化了，此处可直接调用，进一步提高效率
}
```
## 函数调用优先级
由于函数模版、函数重载的存在，编译器需要从众多同名函数中找到或实例化最合适版本的函数去调用。编译器对函数调用的优先级为：普通函数  > 具体化模版函数  > 常规模版函数。

也就是说，如果实参能匹配普通函数和函数模版，则优先匹配普通函数；如果实参只能匹配函数模版，那优先匹配更具体化的。

如果根据以上规则仍无法确定最佳的函数版本，则可能需要对实参进行类型转换来匹配，匹配规则按如下顺序执行，如果转换后匹配到了唯一的函数，则执行函数，否则继续按下一条规则继续类型转换：

1. 精确匹配：不转换，或者只作微不足道的转换，如数组名到指针、函数名到函数指针、T到const T（但是const T不能转换为T）；
2. 整型提升：bool、char、short会统一提升到int、float会提升到double；
3. 标准转换匹配：如int和double的相互转换。
<br/><br/>


# 持续性
变量存储在内存中，但它们在内存中持续的时间不同，主要分成以下四种：

## 自动存储持续性
自动存储持续性的变量（以下简称为自动变量）仅在该变量定义的代码块或函数中存在。因此，这些变量定义在代码块或函数中，并以栈的形式存储在内存中。当执行时到代码块或函数时，栈上会开辟空间，这些变量会被加入到栈中，当离开代码块或函数时，这些变量会被销毁（也就是出栈）。

在C++11中，register关键字用于显式地指定某个自动变量是自动存储持续性的，显然，register在C++中并无特殊作用。但为了兼容性，该关键字还是保留了下来。

## 动态存储持续性
此类变量是通过new分配内存的变量。直到调用delete，这些变量才会被销毁。期间该变量存储于内存的一块堆结构中。

## 线程存储持续性
C++11中新加入的一种持续性，用于并行编程。


## 静态存储持续性
静态存储持续性的变量（以下简称为静态变量）在整个程序运行期间都存在。且在定义时被初始化为零。静态变量有以下三种：

### 使用static关键字，定义在函数内的变量
和自动变量一样，此类变量作用域局限于函数内或代码块中。但是在离开函数或代码块后，该变量仍然存在，并会继承之前的值，在下次进入函数和代码块后继续发挥作用：
```cpp
void F() {
    static int a;
    cout << a << endl;
    if (!a) 
        a++;      
}

int main() {
    F();  //输出0，因为静态变量定义时会被初始化为零
    F();  //继承了上一次的值，输出1
}
```
### 使用static关键字，定义在函数外的变量

在整个文件内部都可使用（作用域为整个文件），但无法跨文件调用（仅有内部链接性）

### 无static关键字，定义在函数外的变量
在整个文件内部均可使用，且可以跨文件调用（外部链接性）。因此在同一程序中，此类变量的变量名均应该是唯一的，否则在跨文件调用时会产生混乱。

在跨文件调用变量时，C++遵循“单定义规则”，即一个变量只能定义在一个文件中，且只能有一次定义，在其他文件中要使用这个变量，使用前必须用“extern”关键字声明且不能初始化该变量。“extern”关键字声明了这个变量是从别的文件中“借调”过来的，而不是定义了一个新的变量：
```cpp
//a.cpp
int a = 1;

//b.cpp
#include "a.cpp"
extern int a;  //如果初始化了，会被认为是重新定义了变量a，违反了“单定义规则”
```
extern声明可以看作是对外部变量的引用，因此不会额外分配存储空间。

<br/><br/>



# 命名空间
如果不同源文件中有同名函数，那在调用时，如何确定调用的是哪个源文件中的呢？这个时候一般需要命名空间来确定。

未完待续，详见书9.3


<br/><br/>

# 参考资料
[C++ const对函数重载的影响](https://blog.csdn.net/weixin_42073412/article/details/99876532)

[C++的函数重载](https://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html)