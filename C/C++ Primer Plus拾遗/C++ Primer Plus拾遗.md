<font color='ff0000'>**本博文整理了《C++ Primer Plus（第六版）》前九章中的部分知识点，基本为Modern C++（C++11标准）的一些特性。**</font>
<br/>


# C与C++的语言特性
## C语言特性
- 结构化编程（Structured Programming）：早期语言（如 Fortran 和 Basic ）在代码组织上可能会存在问题（例如分支语句常常会让代码逻辑和可读性变得特别差）。对此，C语言使用了结构化编程这一方法，将程序中的分支限制为一组易读的代码结构（例如 for、while、do while 循环以及 if else 语句）。
- 
- 面向过程编程（Procedure Oriented Programming）：以过程为中心的编程思想。以“什么正在发生”为主要目标进行编程
- 自顶向下（ top-down ）：将大型程序分解为多个小型、易管理、可重复调用的小任务，这个分解过程可以持续下去，把小任务分解为更小的任务。在C语言中，通过函数来实现“自顶向下”。

## C++语言特性
- 面向对象编程（Object Oriented Programming）：在 C++ 中通过类与对象这两种数据结构及封装、多态、继承等方法实现。类规定了用何数据描述一个物像（或者概念）并规定了如何用这些数据去描述，对象则是根据类的要求构造的而成的，代表某个物像（或概念）的特殊数据结构。因此与面向过程不同，面向对象的重点不在任务上，而在于表示概念。面向对象编程常常从低级组织（类）开始构建，进而构建高级组织（程序），该过程称为自下向上编程（ bottom-up ）
- 泛型编程（Generic Programming）：泛型也是一种特殊的抽象数据结构，相较于面向对象编程关注于数据，泛型编程关注算法本身，因此其不拘泥于数据类型。例如，写一个两数相加返回结果的函数，若输入的数据类型可能为int，也可能为float，则比较麻烦，通过泛型（更具体地说，使用模板）则可较为方便地解决。

- 强类型语言：C和C++都是强类型语言，所有的变量在声明时必须指定其类型，基于此特性C++11标准中做出了许多规范与改进（如auto、decltype、右值引用等语法）

## 可移植性及C++标准
可移植性是指同样的代码，只需要使用针对不同平台设计的编译器进行编译，而不必更改代码本身，就可以跨平台运行（这里所说的平台，是CPU + 操作系统，也就是说，即使操作系统相同，CPU不同，也可能算作不同平台）。然而程序的可移植性的实现有两大阻碍。一是硬件。例如不同的CPU有不同的指令集，这些指令集所构成的汇编语法在不同CPU上可能大相径庭；二是标准。即使是同样的软硬件条件，同一种编程语言由于标准不同语法上可能会有些许差异。

要解决第二种阻碍，可通过制定针对所有平台的统一标准来实现。对此，ISO标准委员会分别于1998、2003、2011年推出了C++标准（分别为C++98、C++03、C++11标准，其中C++03是C++98的补丁版，两者语言特性一致）。之后也ISO也颁布过C++14、C++17等标准。同理，C语言也有国际标准，如C89、C90、C99等（其中C89和C90一样）
虽然C++一般可以视为功能更强大的C，但两者并不能完全兼容。C++标准可“近似地”视为C标准的超集，但也并不是所有的C语言的代码都可正确运行于C++中。

<font color='ff0000'>**C++ Primer Plus 书中所述基于C++98标准，并介绍部分C++11特性。**</font>
<br/><br/>

# 整型
## 分类
C++中的整型有char、short、int、long、long long五种类型（全名分别为short int、long int、long long int，但一般都简写……），每种类型都有有符号版本和无符号版本，因此总共有10种整型。

为了适应日益繁多的字符类型，C++ 还推出wchar_t 类型，C++ 11 标准还加入了char16_t 和 char 32_t 类型。

按ISO/IEC 14882:2011（即C++ 11标准），无符号类型的char、short、int、long、long long的数据范围都不得低于排在它前面的哪一种数据类型，且标准提到了，具体数据范围可根据环境制定。其中，int型应该为“自然长度”，也就是计算机处理起来效率最高的长度，例如在32位系统中，int就占32位，但在16位系统中，int一般只能占16位。当然也有例外，windows64位环境下，int仍然只占32位。


## 整型字面值
除了十进制，C++支持用八进制和十六进制表示整数。

八进制：第一位为0，第二位为0到7的数字，则从第二位开始到结束的一整串数字表示一个八进制整数，如012，表示的数字十进制下为11。

十六进制：第一位为0，第二位为“x”或“X”，则从第三位开始到结束的一整串数字表示一个十六进制整数（A~F大小写均可）。如0xF，表示十进制数15。

无论用何种表示方法，在cout的时候统一转换成十进制表示。当然也可用格式控制符指定显示以何种进制显示：
```cpp
int a = 0xf;
cout<<hex<<a<<endl;    //16
cout<<dec<<a<<endl;    //10
cout<<oct<<a<<endl;    //8
```
## 常数后缀
数字常量后可用字母后缀定义其类型，其中，对于整数来说，“u”表示无符号，“l”表示long类型，“ll”表示ll类型。其中，这些后缀顺序随意，大小写不影响，举一些例子：
```cpp
65536ull
65536llu
999l
999u
```
后缀体系可以和八进制、十六进制混用。

常数后缀的作用：

1. 帮助auto类型推导。

2. 隐式转换。C++中对于整数数字的处理，如果在int范围内就处理为int型，超出则根据平台情况处理为long或long long类型，在用整数数字进行运算时，一般int与int运算，结果默认也为int型，则就会有以下情况产生：
```cpp
long long b = 2100000000 * 2;
```
系统会报错，虽然相乘的结果没有超出long long范围，但两个乘数默认处理为int型，相乘结果也默认为int型，则就超了。正确写法：

```cpp
long long b = 2100000000ll * 2;
```
<br/><br/>

# 浮点型
分为float（单精度）、double（双精度）、long double三种类型，分别为32、64、128位。（和整型数据类型一样，这三种浮点型实际大小也不是全平台固定的，以上结果为Win10系统下所得）

对于float，十进制下有效数字有7位，double则可以达到15位。

## 浮点型常数表示
可以采用类似科学计数法的方式表示浮点型常数：例如，38.675，可表示为：3.8675e+1（E也可以，大小写不限），e后面是10的指数，若指数为正可省略加号。

另外，可以指定浮点型常数的类型。默认情况下为double型，“f”后缀表示float型，“l”后缀为long double型，大小写不限，且可以和上述的科学计数表示法混用。
```cpp
cout<< 3.0000001f - 3;
cout<< 3.0000001 - 3;
```
前者输出0，后者输出1e-007，这是因为3.0000001被指定为float型后，由于只能保证7位有效数字的精度，最后的1就被舍掉了。
<br/><br/>

# 对数据类型的操作
## 变量命名
变量名由下划线、字母、数字组合而成，其中不可用数字作为开头。单个下划线可作变量名。

下划线打头的变量是合法的，但不建议用户自定义变量采取这种命名方式。因为“_”、“__”开头的多为系统库函数和宏的名称，用户如此命名自己的变量可能会影响运行的稳定性。

## 列表初始化
### 普通变量初始化
```cpp
int a = {5};
```
将a初始化为5，其中，“=”可以省略，如果初始化为0，大括号内可以什么都不填。

该初始化方法适用于几乎全部C++自带数据类型：
```cpp
char c{};
string s{"123"};
```
此外，使用列表初始化，对于变量类型要求更为严格：不允许缩窄（narrowing），即变量的类型可能无法表示赋给它的值。如：
```cpp
char a {99999};
char b = 99999;
```
对b的初始化只是warning，但对于a的初始化就是error了……

此外还有：
```cpp
int a = 70;
char b {a};
```
运行的时候虽然只是警告，但也需要注意，在初始化b时，由于a是int型，因此很有可能a中的值会超过b的范围。但相反，给一个int型的变量初始化为一个short型变量的值是被允许的。
### 数组初始化
和普通变量初始化一样，“=”可以省略，如果初始化为0，大括号内可以什么都不填。
```cpp
int a[3] {1, 2, 3};
int b[3] {};
```
同样，数组初始化时每个元素都不允许缩窄：
```cpp
int a[3] {1.0, 2, 3};  //错误，int不允许小数
char b[3] {'a', 999, '\0'};   //错误，999超出char型范围
```
对于字符串、字符数组，可：
```cpp
char c[] {"abcd"};
string s {"abcd"};
```
### 结构体初始化
“=”可以省略，大括号内不写东西则全初始化为0，各元素均不得缩窄。
```cpp
struct Student {
    char name[10];
    int age;
    float score;
};

Student s {"Alice", 15, 89.5};
```
<br/>

## 类型转换
当表达式中含有多个不同的数据类型时，会进行整型提升（integral promotion），bool、char、short及其对应无符号型会被统一转换为int型（bool中的true被转换为1，false被转换为0）。但如果表达式中含有long long类型，则不会作进一步提升。（因此最后运算结果如果超出int范围，即使赋值给long long 型，也会出错）

但如果表达式中涉及到浮点型，则会进一步提升到浮点型，并以最大的类型为准进行提升。举个例子（a的赋值会出错而b不会）：
```cpp
long long a = 2 * 2100000000;
long long b = 2.0 * 2100000000;
```
强制类型转换：(类型名)变量名或常量，类型名(变量名或常量)，举个例子：

```cpp
float a = 1.8;
cout<<(int)9.8;
cout<<int(9.8);
cout<<(int)a;
cout<<int(a)
```
输出9，9，1，1。

## auto声明
一种特殊数据类型，可以根据变量所赋初始值推断变量类型。因此，C++11标准规定在定义auto变量的同时必须进行初始化。
```cpp
auto a = 0;     //推断为int型
auto b = 0.0;   //推断为double型
```
<br/><br/>


# 逗号表达式
将多个表达式作为一条语句，常用于for循环之中。
例如：
```cpp
i++, j--;
```
逗号表达式按从左到右运算，即先进行i++，再执行j--。逗号表达式本身也有值，其返回最后执行部分（也就是整个逗号表达式最右边的值），例如：
```cpp
printf("%d\n", (1,2,3));   //输出3
```
<br/><br/>


# C++11中对数组遍历的简单方法：range型循环
对普通数组或vector等的遍历，可：
```cpp
int a[] {1,2,3,4};
for (int i : a)
    cout << i;      //数组输出

for (int &p : a)
    p += 1;         //数组更改

```
<br/><br/>



# const
const关键字一般用于定义一个普通常量，使其值在运行过程中永远保持其初始化时的值，不被任何操作改变（因此const常量在声明时必须初始化）。此外，const关键字有static的作用，令常量具有内部链接性。
## 常量指针与指针常量

### 定义

指向常量的指针，称为常量指针。指针本身可以被修改，但不可通过该指针改变其指向的内容。

一个指针类型的常量，称为指针常量。该指针无法被修改（指向的地址不变），但地址中的内容可以随意修改。
```cpp
const int * p1;        //常量指针
int const * p2;        //同p1

int * const p3;        //指针常量
const int * const p4;  //其实也是指针常量，但它本身不可被修改，其指向的内容也不可通过该指针进行修改
int const * const p5;  //同p4
```
简单来说，关键字写在\*左边的用于修饰被指向的内容，关键字写在*右边的用于修饰指针本身。因此，const \*是常量指针，\* const是指针常量。

### 应用
常量指针一般用于通过指针传参时，保护指针指向的内容不被修改。而这个被指向的内容本身是不是const，其实无所谓。

例如，保护数组a在函数中不被修改：
```cpp
void PrintArr(const int a[], int n);
```
此时若在函数中更改了数组某元素，编译器会报错。

<br/><br/>


# 函数
## 内联函数
内联函数的作用和宏类似，将调用内联函数的代码替换成函数本身的代码段，以此实现更高的执行效率。

在函数定义前加入“inline”关键字即可定义内联函数。
```cpp
inline double square(double x) { return x*x;}
```

一般高效（代码少，执行快）且频繁调用的函数会被改造为内联函数。实际上，和C语言中的register类似，即使用户将函数定义为内联函数，若函数代码过长，或者函数中存在递归，编译器也不会将其作为内联函数编译。

和宏相比，内联函数在使用上更加方便，也更易理解。尤其在参数传递上更容易规避潜在风险。例如：
```cpp
#define SQUARE(x) x*x

SQUARE(1+2)  //会被替换为 1+2 * 1+2
```
## 默认参数
函数参数可从右向左设置默认值：
```cpp
int Add(int a = 0, int b = 0);
//仅给a设置默认值而不给b设是非法的
//换句话说，如果给某个参数设置了默认值，则该参数右边的所有参数也必须设置默认值
```
在调用Add函数时，传入的实参将按从左到右的顺序赋给形参，若传入的实参不够，形参则会使用默认值：
```cpp
Add(1);   //等价于Add(1, 0)
Add();    //等价于Add(0, 0)
Add(, 1); //错误写法，不可跳过参数
```
## 函数重载
C++支持函数重载，允许定义名字相同的函数，只要其参数表不同即可。（参数数量，参数类型，以及顺序，只要有一处不相同，均视为参数表不同）。参数名并不影响对参数表是否相同的判断。

例如，以下两个函数的参数表是不同的：
```cpp
void Func(int a, float b);
void Func(float a, int b);
```
对于变量及其对应的引用变量，它们分别构成的参数表会被认为是相同的：
```cpp
void Func(int a);
void Func(int & a);
```


在调用函数时，会根据实参类型去匹配对应的函数，若无对应，则会考虑进行类型转换。例如有以下函数：
```cpp
int Add(int*, int*);          
double Add(double, double);   

Add(1.1, 2); //找不到对应版本的函数，则进行类型转换，匹配Add(double, double)类型。
```
如果类型转换后有多个能匹配到的函数版本，则会报错：
```cpp
int Add(int, int);          
double Add(double, double); 

Add(1.1, 2);   //报错，1.1可匹配int也可匹配double
```

对于const类型的形参，非const和const类型的实参均可匹配。但const类型的实参不会匹配非const类型的形参。

另外，对于引用类型和其原类型，在函数重载中被认为是相同类型，因此会报错：
```cpp
int F(int &a);
int F(int a);
```

## 函数模版
如果需要编辑一个能支持多种类型的参数的函数，我们可以使用函数模板，而无需为每一种类型的参数分别开发一个函数：
```cpp
template <typename T>
void Swap(T & a, T & b) {
    T temp;
    temp = a;
    a = b;
    b =temp;
}
```
程序在执行时，编译器会根据传入参数的类型来自动生成对应版本的函数。
<br/><br/>


# 持续性
变量存储在内存中，但它们在内存中持续的时间不同，主要分成以下四种：

## 自动存储持续性
自动存储持续性的变量（以下简称为自动变量）仅在该变量定义的代码块或函数中存在。因此，这些变量定义在代码块或函数中，并以栈的形式存储在内存中。当执行时到代码块或函数时，栈上会开辟空间，这些变量会被加入到栈中，当离开代码块或函数时，这些变量会被销毁（也就是出栈）。

在C++11中，register关键字用于显式地指定某个自动变量是自动存储持续性的，显然，register在C++中并无特殊作用。但为了兼容性，该关键字还是保留了下来。

## 动态存储持续性
此类变量是通过new分配内存的变量。直到调用delete，这些变量才会被销毁。期间该变量存储于内存的一块堆结构中。

## 线程存储持续性
C++11中新加入的一种持续性，用于并行编程。


## 静态存储持续性
静态存储持续性的变量（以下简称为静态变量）在整个程序运行期间都存在。且在定义时被初始化为零。静态变量有以下三种：

### 使用static关键字，定义在函数内的变量
和自动变量一样，此类变量作用域局限于函数内或代码块中。但是在离开函数或代码块后，该变量仍然存在，并会继承之前的值，在下次进入函数和代码块后继续发挥作用：
```cpp
void F() {
    static int a;
    cout << a << endl;
    if (!a) 
        a++;      
}

int main() {
    F();  //输出0，因为静态变量定义时会被初始化为零
    F();  //继承了上一次的值，输出1
}
```
### 使用static关键字，定义在函数外的变量

在整个文件内部都可使用（作用域为整个文件），但无法跨文件调用（仅有内部链接性）

### 无static关键字，定义在函数外的变量
在整个文件内部均可使用，且可以跨文件调用（外部链接性）。因此在同一程序中，此类变量的变量名均应该是唯一的，否则在跨文件调用时会产生混乱。

在跨文件调用静态变量时，需要在相应文件中进行声明，声明时需加入关键字“extern”且不可对变量初始化。例如：
```cpp
//a.cpp
int a = 1;

//b.cpp
#include "a.cpp"
extern int a;  // 如果初始化了，会被认为是重新定义了变量a，这就与a.cpp中的a无关了
```
在b.cpp中按上述方式声明后可直接使用变量a。对于b.cpp来说，a就是外部变量。

声明是对外部变量的引用，因此不会额外分配存储空间。

默认情况下函数也具有外部链接性，跨文件调用函数时，若要在文件前面进行函数声明，需加入“extern”关键字（否则会成为）。若要函数仅在其文件中生效（内部链接性），和静态变量一样，加入“static”关键字即可。
<br/><br/>



# 命名空间
书9.3内容



<br/><br/>
