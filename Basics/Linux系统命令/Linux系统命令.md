# <font color='ff0000'>若无特殊说明，以下大部分命令在Ubuntu 16.04TLS 系统下亲测可用</font>
<br/>

# Ubuntu系统简介
## 历史
1983年，麻省理工学院人工智能实验室的Richard Matthew Stallman发布了他的GNU（“GNU is Not Unix”的递归缩写）工程的初始声明：完成一个名为 GNU 的自由、免费的类UNIX的操作系统，并在之后阐述了其对于自由软件的四大理念：有自由按照自己意愿运行该软件；有自由复制软件并赠与他人；有自由通过对源代码的完全控制而改进程序；有自由发布改进的版本从而帮助社区建设。之后，GNU在社区大量工程师的帮助下茁壮成长。

上世纪九十年代，GNU工程已取得了极大的进展，除了操作系统内核，其他一系列操作系统所需的应用、软件都已开发出来（实际上，GNU的内核Hurd一直在开发，但还不足以正式使用）。1991年，芬兰赫尔辛基大学的Linus Benedict Torvalds基于GNU工程开发出了Linux内核。之后，一个完整的操作系统GNU/Linux风靡全球，现在人们称呼的Linux操作系统，其实就是GNU/Linux（当然，下文将继续简称为Linux）。

2004年，Mark Shuttleworth创造了Ubuntu。Ubuntu基于Linux系统的发行版本Debian开发的，带有图形用户界面GNOME，这使得Ubuntu系统更易于使用，变得更为大众化。 

## Shell
在计算机中，仅操作系统内核可以操纵计算机资源（CPU、内存、硬盘等）。出于安全性及复杂性的考虑，用户不能直接操纵内核，需要一个中间程序来处理用户命令，再转交给内核。在Linux系统下，这个程序称作Shell。

Shell是一种解释型的脚本编程语言，不仅可以用来对系统进行相应操作（类似与Windows下的CMD），还可与C、C++一样用来编程。
Shell语言的解释器也称为Shell，Linux（包括Ubuntu）默认解释器为Bash，位置为/bin/bash。

Ubuntu下Terminal中的命令行也是Shell，但相较于编程语言意义上的Shell，命令行中的Shell在功能及便捷性上相对就差一些。

要编写一个Shell脚本，按Shell语法写即可，写完使用按以下命令运行即可，脚本文件后缀名一般会设置为.sh，使用其他后缀名（甚至没有）亦可。

```bash
bash 脚本文件名
```
<br/><br/>

# 系统管理
## 查看系统信息
```bash
# 查看内核/操作系统/CPU信息
uname -a 

# 查看操作系统版本（如Ubuntu 18.04LTS）
cat /etc/issue

# 查看开机信息
dmesg
```
## 内核管理
```bash
查看已安装内核
dpkg --get-selections | grep linux-image

# 删除旧的、不使用的内核
sudo apt-get remove 内核名

# 若不想让系统自动更新内核，可
sudo apt-mark hold 当前使用的内核名
```
## 用户管理
```bash
# 查看当前终端登录的用户
whoami

# 查看当前所有登录系统的用户
who

# 退出当前账户
exit

# 切换到指定用户
su 用户名

# 切换用户并将当前工作目录切换到目标用户主目录
su - 用户名

# 更改密码
passwd
```
## 环境变量
通过export命令设置变量，仅可在当前登录的shell中生效。
```bash
export 变量名=值

# 可选参数：
-n  # 删除指定变量
-p  # 列出当前shell中的环境变量
```

<br/><br/>

# 路径管理
对于路径、文件中存在的空格，可通过转义字符“\ ”来表示。（注意转义字符后有一个空格）

## pwd
查看当前路径

## cd
```bash
# 进入下级目录
cd 目录名

# 回到上级目录
cd ..

# 回到根目录
cd /

# 回到当前用户主目录
cd ~
```

## ln
创建链接（即快捷方式）

例如，目录/mnt/c/Users/ZergWang/Desktop我常常访问，但从/home一路cd过去过于麻烦，可以：

```bash
ln -s /mnt/c/Users/ZergWang/Desktop ~/desktop
```
-s表示创建为软链接（符号链接），没有-s为硬链接。硬链接限制颇多，一般使用软链接。

第一个参数为目标路径，第二个参数为该快捷方式所处位置。

之后在~/下cd desktop即可。

删除链接：
```bash
rm -rf 链接名
```
注意链接名后面没有斜杠。
<br/><br/>

# 文件管理
## 带权限的文件管理器
如果想在图形界面中进行文件管理而又不受权限影响，可以使用带权限的文件管理器：
```bash
sudo nautilus
```
## 文件默认颜色
白色：普通文件（如txt，html之类的）

<font color='0000ff'>蓝色：目录</font>

<font color='1E90FF'>浅蓝色：链接</font>

<font color='ff0000'>红色：压缩包</font>

<font color='00ff00'>绿色：可执行文件</font>

## cat
用于将文件内容输出到指定位置。
```bash
# 输出到屏幕
cat 文件名

# 将文件1的内容输出到文件2
cat 文件1 > 文件2

#参数：
-n    输出时同时输出行号
-b    同上，但空行不编号
-s    将连续的空行压缩为一行空行
```

## chmod
chmod用于更改文件权限。

文件权限通过十个字符展示，例如```-rwxr--r--```。

第一位用于标识是普通文件（“-”）还是目录（“d”）。后面每三位为一组，一共三组，依次为文件所有者的权限、与文件所有者同一用户组的用户的权限、除前两者之外的其他用户的权限。每组的三个字符依次表示读（“r”）、写（“w”）、执行（“x”）权限。如果没有对应权限，则显示“-”。

chmod具体命令形式：
```bash
chmod 参数 文件名
```
参数由三部分组成，第一部分指定被更改权限的用户：
```bash
u    #即user，表示该文件的所有者
g    #即group，表示与该文件同一用户组的用户
o    #即other，表示除u和g之外的用户
a    #即all，即所有用户
```
第二部分指定如何更改权限：
```bash
+    #增加权限
-    #撤销权限
=    #指定权限
```
第三部分指定要更改的权限：
```bash
r    #读，对应数字4
W    #写，对应数字2
x    #执行，对应数字1
-    #无任何权限，对应数字0
```
例如，将某文件更改成所有用户均可读取：
```bash
chmod ugo+r 文件名
#也可以写成：chmod a+r 文件名
```

此外，也可用三位数字作为参数来修改权限，三位数字分别代表三类用户的权限，将需要的权限的对应数字相加即可。

例如，要将文件所有者的权限修改为可读可写可执行，则第一位数字为4+2+1=7；将同用户组的权限修改为可读，则第二位数字为4；关闭其他用户的所有权限，则第三位数字为0，则执行命令：
```bash
chmod 740 文件名
```

## chown
将文件的拥有者更改为指定用户组下的指定用户。一般仅root用户能使用该命令。
```bash
chown 用户名:组名 文件名
```

## cp
复制文件到指定目录
```bash
cp 原路径 目标路径
```
目标路径必须存在，否则会报错（执行过程中不会自动创建）。如果指定了一个目标路径的一个新文件名，在复制时可以顺便改名。

cp命令支持入以下参数：
```bash
# 若目标文件已存在会询问是否覆盖，不带该参数则直接覆盖
-i 

# 递归复制，用于非空目录的复制
-r 

# 不经询问强制执行
-f 
```

## diff
比较两个文件或目录的异同
```bash
diff 文件1 文件2
diff 目录1 目录2
```

## du
查看指定目录或文件占用的磁盘空间。

## find
用于查找指定文件
```bash
find 指定查找的路径  -name 要找的文件名
```
例如，在当前目录查找main.cpp文件：
```bash
find . -name "main.cpp"
```
文件名要在双引号中， “.”表示在当前目录下搜索

## grep
查找指定文件中符合条件的字符串或正则表达式。第三个参数可以是完整文件名或者要匹配的文件的正则表达式（例如a*.txt来匹配a开头的txt文件）。如果需要在指定目录中递归查找所有文件，第三个参数则为目录名或者目标目录的正则表达式。

```bash
grep 目标字符串的正则表达式 文件或目录的正则表达式  
# 若不加下列参数，则返回匹配到的字符串所在的整行信息。

-E    使用拓展版本的正则表达式来匹配（等价于egrep命令）
-i    不区分大小写
-c    只返回含目标串的行的数量
-n    显示目标串所在行的行号
-s    不显示错误信息及匹配不到内容的信息
-r    递归搜索子目录
-v    反向搜索，返回不含指定字符串的行的内容
-o    不显示匹配字符所在行的整行信息，仅显示匹配到的字符串
```

grep也可与其他命令一起使用，用于从其他命令的返回结果中搜索目标字符串：

```bash
其他命令 | grep 目标字符串的正则表达式
```

## gzexe
加密并压缩文件（假设明文的文件名为a.txt）
```bash
gzexe a.txt
```
加密完成后，a.txt就变成了密文文件，加密前的明文被备份为a.txt~

解密文件：（假设密文文件名为b.sh）
```bash
gzexe -d b.sh
```
解密完成后，b.sh变成了明文文件，密文会被备份为b.sh~

## head
显示文件前10行的内容：
```bash
head -n 10 文件名
```

## less
和more类似，用于查看文件内容，但功能要比more更全面。

## ls
查看指定目录下的文件信息
```bash
-a # 查看当前目录下的文件（包括以.开头的隐藏文件）
-d # 只查看目录（不递归显示目录内的文件）
-l # 查看当前目录下文件详细信息（包括权限信息）
-r # 倒序显示
-R # 递归显示目录中的所有文件和子目录
-t # 查看以修改时间排序的文件信息（新的在前面）
```

## mkdir
创建目录：
```bash
mkdir 目录名
```
-p为递归创建，假设要创建目录的沿途目录均未创建，则一同创建。

## more
类似于cat，用于将文件内容输出到指定位置（包括屏幕），适合查看内容比较多的文件。more功能较为单一，早期的more甚至只支持向后翻页查看文件。
```bash
# 查看文件
more 文件名

# 查看界面的命令
Space    下一页
b        上一页
q        退出
Enter    下一行
=        输出当前行号
```

## mv
移动文件到新目录，操作与cp类似。

也可以用于重命名文件：mv 旧名 新名

## rm
```bash
# 删除文件
rm 文件名

# 删除空目录
rm -d 目录名

# 删除非空目录
rm -r 目录名

# 删除目录下全部内容，但不删该目录
rm -r 目录名/*

-f为强制执行，慎用。

# 清空回收站
sudo rm -rf ~/.local/share/Trash/*

# 删库跑路
rm -rf /*
```

## sort
对文件中的每行内容排序。

假设文件a.txt的内容为：
```bash
abc
eaa
bgg
aaa
```
使用```sort a.txt```排序：
```bash
aaa
abc
bgg
eaa
```
可选参数有：
```bash
-b # 忽略行首的空白字符
-f # 排序时忽略大小写
-k 3 # 按第3列的值的大小排序
-n # 按数值大小排序
-r # 降序排序（默认升序）
```

##  tail
显示文件后10行的内容：
```bash
tail -n 10 文件名
``` 

## touch
创建文件
```bash
touch 文件名
```

## 解压及压缩
zip压缩包的解压及压缩：
```bash
unzip 文件名
zip 压缩包文件名 原文件名
```
tar压缩包解压方式：
```bash
tar –xvf 文件名
```
tar.gz压缩包解压：
```bash
tar –xzvf 文件名
```
## 跨系统的文件传输
在同一局域网下与Windows系统进行文件互传，可在Windows下安装FileZilla软件实现。然后在Ubuntu系统中安装ssh服务即可。
```bash
sudo apt-get install openssh-server
sudo service ssh start
```

<br/><br/>

# 磁盘管理
## df
查看磁盘使用情况

## fdisk
用于磁盘分区的工具，可以创建、编辑、删除和显示硬盘分区。

```bash
fdisk -l  # 显示磁盘分区信息
```
<br/><br/>

# 进程管理

## ps
```bash
# 查看当前运行的进程
ps r

# 查看所有进程
ps -e 或 ps -A

# 查找指定进程
ps -ef | grep 进程关键字
```
## top
可持续监视进程的使用情况以及系统负载，相较于ps功能更完善。

```bash
-d n    # 每隔n秒执行一次top
-H      # 显示线程的详细信息
-p PID  # 显示指定PID的进程信息
-u user # 显示指定用户user下的进程信息
```
## htop 
比top命令更高级，功能更完善。



## kill
给指定PID的进程发送信号
```bash
# 查看所有信号类型
kill -l

# 终止进程（系统会逐步释放资源，终止进程，但也有可能终止失败）
kill PID

# 发送SIGKILL信号给进程，令其被强制终止
kill -9 PID
```
## 作业（即job）管理
终止当前终端运行的作业：Ctrl + c

终止当前终端运行的作业，但将其保留并挂起：Ctrl + z
```bash
# 查看被挂起的作业（每行代表一个被挂起的作业，行首数字为其作业号）
jobs

# 在前端恢复挂起的作业
fg 作业号

# 在后端恢复挂起的作业
bg 作业号
```
<br/><br/>

# 内存管理
## free
查看当前内存使用情况。
```bash
-h # 显示时使用合适的单位（G、M或K）
-s n # 每隔n秒查看一次内存
```
以下是free -h的结果展示
```bash 
        total   used    free    shared    buff/cache    available
Mem:    6.7G    394M    5.7G    2.8M      633M          6.1G
Swap:   2.0G    0B      2.0G
```
第一行显示的是物理内存的使用情况，第二行是交换内存的使用的情况（交换空间实际上是硬盘上的一个文件，当物理内存紧缺时会将不常用的内存数据换出到交换空间中）。

total列显示系统总的物理内存或交换空间的大小。used列显示已经使用的内存/交换空间。free目前空闲的内存/交换空间，shared列显示被共享使用的内存。

buff/cache显示buffer和cache使用的内存。这两块内存起到减少磁盘读写速度，提高效率的作用。其中，buffer一般用于缓存要写入到磁盘的数据。当有多个要写入到磁盘的数据时，一般会先存储在buffer中，当buffer满了再将数据一次性写入到磁盘中，减少对磁盘的写入次数，提高效率。cache一般用于缓存读取的磁盘数据。当这些磁盘数据需要被反复访问时，就直接从cache中读取，减少对磁盘的读取次数。

available显示可用的内存大小。在Linux看来，buffer和cache空间是起到提高读写效率的作用，本身并不会存储更多的数据。因此，当free的内存不足时，Linux会从buffer和cache中分配内存来使用。因此，availab的内存约等于free加上buffer/cache。

<br/><br/>

# 网络管理
## ifconfig
查看并设置网卡。
## hostname
```bash
# 查看当前主机名
hostname  

# 临时更改主机名（重启后失效）
hostname 新主机名
```
通过修改/etc/hostname文件可实现永久修改主机名。

<br/><br/>


# 其他Terminal命令
## 执行脚本
以下执行脚本的命令，除了exec，其他只能执行按Shell语法编写的脚本（.sh文件），不能执行二进制文件。
### sh
```bash
sh 脚本名
```
使用sh命令执行脚本，当前的shell会作为父进程fork一个子进程，然后在子进程中执行脚本。

在Shell中直接输入脚本的绝对或相对路径，默认也是使用sh命令执行脚本，例如：
```bash
/home/zerg/a.sh
```
### source
在当前Shell进程中直接执行脚本，不会创建子进程。
```bash
source 脚本名
```
source命令可以简化为“.”，例如：
```bash
. 脚本名
```
脚本对Shell上下文的修改在执行结束后仍会保留，例如，脚本切换了工作目录，当脚本结束后，Shell会保持在脚本切换的工作目录中。sh命令由于在新fork的子进程中执行脚本，脚本的操作不影响当前的Shell。

### exec 
```bash
exec 脚本或可执行文件
```
exec命令会令当前执行的脚本或二进制文件占据当前的Shell，并使用当前的Shell的PID，执行结束后会当前Shell也会被关闭。

## alias
```bash
alias
# 查看所有已设置的别名
alias 别名 = 命令
# 设置别名，例如alias nvi='nvidia -smi'
unalias 别名 
# 取消某个别名的设置
```
以上设置仅在当前终端有效，换终端或重启就失效了。若要永久生效，需要修改~/.bashrc文件。
## perf
linux自带的性能分析工具。

分析指定PID的程序运行时堆栈调用情况，连续追踪t秒：
```bash
perf record -F 99 -p PID -g -- sleep t
```
数据存储在当前目录下的perf.data中
## watch
```bash
# 自动反复执行某些命令
watch [参数] [命令]

# 参数有：
# 后接数字，表示每隔多少秒执行一次（默认为2秒）
-n

# 高亮显示与上次执行命令时结果不同之处
-d

# 隐藏执行命令时的watch的标题
-t
```
举个例子，每隔1秒查看一次显存占用情况，隐藏watch的标题并高亮显示变化部分：
```bash
watch -n 1 -t -d nvidia-smi
```
## 管道符

即“|”符号。管道符用于将两个命令分隔开，并令前一个命令的输出作为后一个命令的输入。管道符可连续使用，例如：
```bash
cat a.txt | sort | uniq | cat > b.txt
```
整体命令的作用是，首先将a.txt的内容输出给sort命令，然后执行排序，将排序的结果进行去重，最终结果输出到b.txt中。

## 注释
以“#”为开头的一行即为注释

## 清屏
Ctrl+L或者clear命令


## 图形界面下与Terminal交互
打开Terminal：Ctrl +Alt + T

复制：Ctrl+Shift+ C

粘贴：Ctrl + Shift + V
<br/><br/>


# 参考资料
[Shell脚本：Linux Shell脚本学习指南（超详细）](http://c.biancheng.net/shell/)

[About the GNU Operating System- GNU project - Free Software Foundation](http://www.gnu.org/gnu/gnu.html)

[Linux 命令大全 | 菜鸟教程](https://www.runoob.com/linux/linux-command-manual.html)
