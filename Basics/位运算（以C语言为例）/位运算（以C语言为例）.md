# 位运算符号介绍
本篇博文部分思路及图表来自MoreWindows博客，原文链接：https://blog.csdn.net/MoreWindows/article/details/7354571

**本文所涉及操作均以C语言为例，以下操作仅能对整型数据使用。**

**注意：位运算优先级较低，为保证正确，建议添加括号。**

| 符号 | 描述 | 运算规则 |
| ---- | ---- | ---- |
| &    |  与  |  两位都为1时，结果才为1 |
| \|   |  或  |  两位都为0时，结果才为0 |
| ^    | 异或 |  两位相同为0，不同为1（异或可看作不进位的加法运算）   |
| ~    | 按位取反 | 唯一的单目运算符，将0变1，1变0 |
| <<   | 左移 | 左移若干位，高位丢弃，低位补0   |
| >>   | 右移 | 右移若干位，对无符号数，高位补0 |

**不同编译器对有符号数的右移运算处理方法不一样（在Dev C++中负数也是直接除以2**

**注意：进行左移时，请保证移动的位数小于变量占用的bit的数量。以int型（32bit，取值范围为$[-2^{31} ,  2^{31}-1]$）为例，左移31位，即1<<31 = 2^31，部分编译器会令变量wrap out成-2^31，但有些编译器会直接报错，因此保险起见最多左移30位**

**接下来介绍部分位运算技巧**
<br/><br/>

# 位运算操作技巧
## 乘除
右移n位，即原始值除以$2^n$，左移n位，原始值乘以$2^n$。
```cpp
int a=10, b=10;
a <<= 2;
b >>= 2;
```
a左移2位，即a的值乘以$2^2$，也就是乘以4，即40。
b右移2位，即b的值除以$2^2$，也就是除以4，即2。

## 取符号位
判断变量的符号：
```cpp
int sign = a >> 31; 
```
（a为int型，有32位，右移31位即可得到符号位，若a<0，则sign为-1，其他则为0）。如果a右移31位后的值赋值给布尔型变量，则a<0时布尔值为1，其他为0。

## 取任意位
取a的第p位（从右往左数，最右边为第0位），赋值给b。
```cpp
int b = a >> p & 1; 
```
若a的第p位为0，则b为0，否则为1。

## 将任意位置为0或1
```cpp
a |= 1 << p;    //将变量a的第p位（从右往左数）置为1
b &= ~(1 << p); //将变量b的第p位（从右往左数）置为0
```

## 取相反数
```cpp
int signReverse = ~a+1;
```
由于计算机使用原码、反码、补码的方式存储数据，int范围内所有数字按位取反后加1都等于其相反数。除了$-2^{31}$，它按位取反加1后等于自己。

上述两种方法结合，可以写出一种非常高端的取绝对值的函数：
```cpp
int GetAbs(int a) {
    int t=a>>31;
    return (a^t)-t;
} 
```
用t取得a的符号位，任何数与0异或值不变，与1异或值取反，之后若a为负数 再减去-1，即加1。
（该方法同样对-2^31无效）

## 判断是否为2的次方
[LeetCode 231](https://leetcode.com/problems/power-of-two/)
```cpp
bool isPowerOfTwo(int n){
    return n > 0 && (n & (n - 1)) == 0;
}
```

<br/><br/>

# 异或运算技巧 



## 模拟开关
由于“~”是按位取反，因此对于值为True的bool型变量（8位存储空间，实际值为00000001），取反后变成11111110，还是True。因此要模拟开关，需使用异或操作。

```cpp
bool s = 0;
s ^= 1;   //每执行一次，s就会从0变1，或从1变0。
```

## 两数交换
```cpp
void Swap(int a, int b) {  
    a ^= b;  
    b ^= a;  
    a ^= b; 
}  
```
异或满足交换律，且一个数a对另一个数b连续异或两次，得到它自己。（即a\^b\^b=a）

## 异或在LeetCode中的使用技巧

### [LeetCode 136](https://leetcode.com/problems/single-number/)


数组中有n个元素。其中一个特殊元素仅在数组中出现一次，其他每个元素会在数组中出现两次。在$O(N)$时间找出这个特殊的元素。

利用异或运算的特性（a\^b\^b=a），令0与数组中每个元素相异或，最终结果即为特殊元素。

```cpp
int singleNumber(int* a, int n){
    int ans = 0;
    for (int i=0; i<n; i++) 
        ans ^= a[i];
    return ans;
}
```

### [LeetCode 137](https://leetcode.com/problems/single-number-ii/solutions/)

数组中有n个元素。其中一个特殊元素仅在数组中出现一次，其他每个元素会在数组中出现三次。在$O(N)$时间找出这个特殊的元素。


首先可以累计数组所有元素在每个bit位“1”的数量（假设该结果为sum），sum mod 3后即可得到特殊元素。

值得注意的是，除了特殊元素，数组中其他所有元素的在各个bit位“1”的数量之和，必定都是3的倍数，因此我们可以统计数组所有元素在每个bit位“1”的数量之和。假设$s_i$为数组所有元素在第$i$位的“1”数量之和，$s_i \mod 3$即为特殊元素第$i$位的值。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& a) {
        int ans = 0;
        for (int i=0; i<32; ++i) {  
        // 统计数组所有元素在第i位上“1”的数量
            int cnt = 0;
            for (int j: a) 
                cnt += j >> i & 1;
            if (cnt % 3)
                ans |= 1 << i; 
        }
        return ans;
    }
};
```


异或操作本质上来说，是一种不进位的加法运算，或者说是一种“模2加法”运算。a\^b等价于a和b逐位相加再mod 2。例如 1100 ^ 1001，首先逐位相加得到 2101，然后逐位mod 2，得到 0101。

那么在这道题中，可以将异或运算改造成“模3加法”，这样就能使用与[LeetCode 136](https://leetcode.com/problems/single-number/)相同的思路去找特殊元素。

具体改造可参考以下教程： [带你一步步推导出位运算公式！](https://leetcode.cn/problems/single-number-ii/solutions/2482832/dai-ni-yi-bu-bu-tui-dao-chu-wei-yun-suan-wnwy/)