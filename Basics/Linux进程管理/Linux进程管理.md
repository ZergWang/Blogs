# 进程的构造
运行中的程序被称为“进程”（Process）。每个进程中都有一个称为进程控制块（process control block，PCB）的数据结构来描述进程。PCB中包括进程标识符（PID）、用户标识符（进程从属的用户）、进程优先级、进程当前状态、CPU寄存器数据等信息。


# 进程的状态
## 创建状态（New）
创建一个新的进程。进程一般由其他进程调用fork()函数创建，刚创建出的进程会被分配一个空白的PCB，然后为其分配相关信息（例如PID），这些信息会填入其PCB中。然后，操作系统为新进程分配其虚拟内存空间。

## 运行状态（Running）
此时进程占据CPU，CPU在全力处理进程的指令。当CPU空闲时，操作系统会根据调度算法，从就绪队列中选择合适的进程转为运行状态，并令CPU处理该进程。

## 就绪状态（Ready）
可以运行，但由于CPU在处理别的进程而处于的等待状态。所有就绪状态的进程会以链表的形式组织在就绪队列中。处于创建状态的进程在其PCB以及虚拟内存空间准备完毕后，会进入就绪状态（被加入就绪队列中）；阻塞状态中的进程在结束其事件后（例如IO结束后），其他进程会发送信息将其“唤醒”（阻塞状态的进程不能自行唤醒）。然后阻塞状态的进程会从阻塞队列移动到就绪队列中。


## 阻塞状态（Blocked）
该进程本来正在运行，但由于某些事件（例如等待IO）而停止运行。此时操作系统会保存该进程在CPU中运行时的环境与数据（例如CPU寄存器中的数据），然后将该进程放入以链表的形式组织的阻塞队列中。

## 挂起状态（Suspend）
为了防止大量处于就绪或阻塞状态的进程占用物理内存，这些进程有可能会被从内存移动到硬盘中保存。此时这些进程进入挂起状态。因此挂起状态可分为阻塞挂起状态（进程在硬盘中等待事件处理）以及就绪挂起状态（进程保存在硬盘中，但只要进入内存，就可直接进入就绪队列）。

在Linux中，可通过ctrl + z或sleep()函数让进程挂起。

![](Linux进程管理_1.jpg)

## 结束状态（Exit）
进程运行完成，或者出错时，会被操作系统作结束状态处理。


# 进程与线程


# 进程调度
## 调度原则
当运行状态的进程变成结束状态，或者因为某些事件阻塞时，操作系统就需要从就绪队列中挑选一个进程进入运行状态，这一过程称为进程调度。

进程的调度需要考虑到以下指标：

- 系统吞吐量：即单位时间内CPU完成进程的数量。如果某些长作业长期占用CPU，会导致系统吞吐量下降。理想的调度算法应提高系统吞吐量。
- 周转时间：进程的周转时间等于其运行时间、阻塞时间、等待时间（在就绪队列中的时间）的总和。理想的调度算法应降低进程的周转时间。
- 响应时间：用户提交请求到系统第一次产生响应所花费的时间。对于交互式的进程，响应时间是衡量调度算法好坏的主要标准。

## 调度算法

## 先来先服务算法（First Come First Serve，FCFS）
非抢占式算法，调度时选择最早进入就绪队列的进程来运行。该算法对于长作业有利，但不利于短作业。试想，假设某个进程A运行时间很短，但它排在一个运行时间很长的进程B后面。则进程A的等待时间可能远远长于其运行时间。

## 最短作业优先算法（Shortest Job First，SJF）
非抢占式算法，调度时选择就绪队列中运行时间最短的进程来运行。

## 时间片轮转算法（Round Robin，RR）

## 多级反馈队列调度算法（Multilevel Feedback Queue）

# 参考信息
[进程、线程基础知识](https://xiaolincoding.com/os/4_process/process_base.html)