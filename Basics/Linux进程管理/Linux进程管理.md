# 什么是进程
## 进程的构造
运行中的程序被称为“进程”（Process）。每个进程中都有一个称为进程控制块（process control block，PCB）的数据结构来描述进程。PCB中包括进程标识符（PID）、用户标识符（进程从属的用户）、进程优先级、进程当前状态、进程页表地址、CPU寄存器数据等信息。所有进程的PCB均存储在内存的内核空间中。

## 进程的状态与原语
进程有创建、运行、就绪、阻塞等多种状态，同一时刻进程只能处于其中的某一种状态。

进程的状态会在发生某些事件后切换。进程控制原语（Primitive）用于控制及切换进程的状态，这是一组特殊的程序，其执行具有原子性。
![](Linux进程管理_1.jpg)
### 创建状态（New）与创建原语
当用户登录、作业调度或用户请求某些系统服务时，操作系统会调用创建原语来创建进程；进程本身也能调用创建原语来创建另一个进程。

创建原语会创建一个处于创建状态的新进程，主要步骤如下：
1. 为新进程分配PID，并申请一个空白的PCB；
2. 为新进程分配相关资源（如虚拟内存空间）；
3. 初始化PCB，将进程相关信息填入其PCB；
4. 将该PCB加入就绪队列。

之后，进程就转变为就绪状态。

### 运行状态（Running）与切换原语
假设进程A占据CPU，CPU在全力处理进程的指令，此时A处于运行状态。当CPU调度时，操作系统会根据调度算法，从就绪队列中选择合适的进程B，并调用切换原语，进行进程的上下文切换：

1. 保存A在CPU中运行时的环境与数据（即A的上下文信息）到A的PCB中；
2. A的状态被改为就绪状态，并加入就绪队列；
3. 将B的上下文信息加载到CPU中，B的状态从就绪态改为运行态。

之后，CPU开始处理进程B。

### 就绪状态（Ready）

可以运行，但由于CPU在处理别的进程而处于的等待状态。所有就绪状态的进程会以链表的形式组织在就绪队列中。处于创建状态的进程在创建原语执行完后会进入就绪状态；阻塞状态的进程在结束其事件后（例如IO结束后），其他进程会发送信息将其“唤醒”（阻塞状态的进程不能自行唤醒）。然后进程转为就绪状态，并从阻塞队列移动到就绪队列。


### 阻塞状态（Blocked），阻塞原语及唤醒原语
进程正在运行，但由于某些事件（例如等待IO）而停止运行。此时操作系统会调用阻塞原语，将该进程转为阻塞状态。阻塞原语的主要步骤为：
1. 找到对应进程的PCB，保存该进程在CPU中运行时的环境与数据（即进程的上下文信息）；
2. 暂停进程的运行，将该进程放入以链表的形式组织的阻塞队列中。

当阻塞进程的事件结束后，调用阻塞原语的主体需调用唤醒原语来唤醒进程。因此，一般来说，这两个原语成对使用。

唤醒原语的主要步骤：
1. 找到对应进程的PCB，将其设置为就绪状态；
2. 将PCB插入就绪队列，等待被调度。

### 挂起状态（Suspend），挂起原语及激活原语
为了防止大量处于就绪或阻塞状态的进程占用物理内存，这些进程有可能会被从内存移动到硬盘中保存，并变成挂起状态。因此挂起状态可分为阻塞挂起状态（进程在硬盘中等待事件处理）以及就绪挂起状态（进程保存在硬盘中，但只要进入内存，就可直接进入就绪队列）。

在Linux中，操作系统会因为内存不足调用挂起原语，用户手动操作（例如ctrl + z或sleep()函数让进程挂起）也会调用挂起原语，令进程进入挂起状态。挂起原语的主要步骤：

1. 找到对应进程的PCB，根据其原有状态，转变为阻塞挂起或就绪挂起状态。
2. 申请外存交换区空间，将进程换出到磁盘上，并将磁盘地址写入PCB。
3. 回收进程的内存空间。

激活原语用于将进程从挂起状态恢复为原有的阻塞状态或就绪状态，主要步骤为：
1. 找到对应进程的PCB，根据其中的磁盘地址确认进程数据在磁盘上的存储位置。
2. 为进程分配内存空间，将进程换入。
3. 更改进程状态，并加入对应的就绪队列或阻塞队列。

### 结束状态（Exit）与撤销原语
进程正常运行完毕、出错或者被用户/父进程强制终止时，撤销原语会被调用，进程进入结束状态。

撤销原语的主要步骤如下：
1. 找到对应进程的PCB，如果该进程正在运行，立刻停止并让CPU调度其他进程；
2. 终止该进程的所有子进程；
3. 将该进程的资源归还给父进程或操作系统；
4. 删除该进程的PCB。

## 进程相关概念
### 作业
作业的概念主要用在批处理系统中。作业（job）是用户需要计算机完成的某项任务，一项作业可能需要一个或多个进程来完成，但一个进程只能属于一个作业。

### 进程相关名词
下面各种进程的概念用于描述进程特性，并不是用于严格给进程分类的。

- 前台进程/后台进程：前台进程运行于当前与用户交互的终端上，占用终端，且输出的信息都会显示在屏幕上。如果终端异常关闭，进程也会被终止。后台进程不占用终端，在系统中默默运行，不受到当前终端的影响，进程输出的消息也不会显示到屏幕上。

- **交互进程**：由一个shell启动的进程，可在前台/后台运行。

- **批处理进程**：由多个进程构成，按顺序逐个执行。可在前台/后台运行。

- **监控进程（守护进程）**：在后台运行，不受任何终端控制，一般是执行特定系统任务的特殊进程。

- **init进程**：启动Linux后第一个运行的程序，用于管理其他所有进程，也是所有其他进程的父进程。init进程的PID恒为1。由于该进程没有父进程，其PPID恒为0。

### 父子进程

父子进程是一个相对的概念，假设进程A通过fork创建了进程B，则进程A是B的父进程，B是A的子进程。子进程被创建后，会被分配一个独有的PID，以及一个PPID，用于记录其父进程的PID。

若子进程的父进程已经结束，但子进程本身仍在运行，则它变成**孤儿进程**。孤儿进程会被init进程接管并清理，其PPID会被设为1。因此孤儿进程一般不会对系统造成危害。

子进程完成任务后，通知父进程并进入结束态。父进程应回应子进程，将其从进程表中移除。但如果父进程忽略了子进程，或者没有正确处理该子进程，子进程就会变成**僵尸进程**。僵尸进程占用极少的内存空间，且不会执行任何指令。但大量的僵尸进程仍会造成内存资源的浪费。因此应尽量避免僵尸进程的产生。对于僵尸进程，可以强制父进程处理它们，也可以终止父进程，僵尸进程就变成孤儿进程，让init进程来接管。

#### 写时复制
子进程在创建后，会被分配自己的内存空间，并将父进程内存空间中的大部分数据，例如代码段、数据段和文件描述符等复制过来。但很多时候子进程并不会改写自己内存空间中的数据，此时完全可以让子进程直接使用父进程内存空间的数据，就可以避免分配物理内存给子进程以及数据复制的操作，直到父进程或子进程要改写数据。

上述过程即“写时复制”（copy-on-write，简称COW）机制。子进程创建后并不会为它分配物理内存，其使用的虚拟页对应的是父进程的物理页。而父进程的物理页的页头会有专门一块内存空间存储该物理页的引用计数。每当有一个子进程共享了父进程的某个物理页，该物理页的引用计数就加1。

当子进程要修改其某个虚拟页中的数据时，内核才会为该虚拟页映射空闲的物理内存。虚拟页原来对应的父进程物理页的引用计数减1。

### 内核态与用户态
CPU指令集是CPU操作软硬件的媒介，每一条汇编语句都对应了一条CPU指令。多条指令就构成了指令集。在Linux中，指令集被划分出两个权限：ring 0和ring 3。其中ring 0权限高，可以使用全部指令集。ring 3权限低，很多能直接操作硬件的指令集（例如硬盘IO、网卡访问、申请内存等）被禁止使用。当CPU能执行ring 0权限下的指令，即处于内核态。若只能执行ring 3下的指令，即处于用户态。

一般情况下CPU处于用户态执行指令。但出现以下情况，则会切换为内核态：

- 系统调用：CPU处理进程的指令时，如果进程通过系统调用来申请操作系统的一些高权限操作，则会切换为内核态。

- 异常：当进程运行时发生错误或某些意外的异常（例如缺页异常），会切换为内核态运行。

- 外部中断：当某些外部硬件设备完成了用户的指令，CPU会中断当前的指令，并转为内核态去处理外部硬件。

<br/><br/>

# 进程通信
每个进程会被分配各自独占的虚拟内存空间，该空间无法被其他进程访问。因此，进程间通信或数据交互需要通过以下渠道进行：
## 管道
Linux中的管道可以简单类比成一条连接两个进程的“水管”，数据从进程处出发，从一头流入管道，再从另一头流出，抵达另一个进程，因此管道允许流式的数据传输。

单个管道其实可以实现半双工通信，一般多个进程不同时使用管道的读端或写端，则不会发生冲突。
### 匿名管道
Linux命令中的管道符“|”就是一种匿名管道，让前一条指令的结果流入后一条指令。另外，在C语言中可以使用如下函数创建匿名管道：
```cpp
int pipe(int fd[2])
```
其中，```fd[0]```为管道的读取端描述符（相当于管道的“出口”），```fd[1]```为管道的写入端描述符（相当于管道的“入口”），进程通过这两个描述符来进行读写操作。下面是一个使用匿名管道通信的简单例子：
```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
 
using namespace std;

int main() {  
    int fd[2] = {0};  
    int n = pipe(fd); //父进程建立匿名管道
    pid_t id = fork(); //创建子进程

    if(id == 0) { //子进程
        close(fd[1]); //关闭写端
        char read_buffer[16];
        memset(read_buffer, 0, sizeof(read_buffer));
        ssize_t n = read(fd[0], read_buffer, sizeof(read_buffer)); //从管道读取
        cout << read_buffer << endl;
        close(fd[0]); // 通信完毕，关闭读端
        exit(0);
    }

    //父进程
    close(fd[0]); //关闭读端
    char write_buffer[16] = "Hello Pipe";
    write(fd[1], write_buffer, strlen(write_buffer)); //向管道写入
    pid_t rid = waitpid(id, nullptr, 0); //等待子进程
    close(fd[1]); // 通信完毕，关闭写端
    return 0;
}
```
上述代码的管道通信模式如下图所示：
![](Linux进程管理_2.jpg)

使用匿名管道，还需要通信的两个进程为父子关系（如上面的代码所示的通信模式），或者两个进程都被同一祖先进程创建，Linux命令中的管道符就采用这一模式，通信前后的两个进程都是Shell创建的：

![](Linux进程管理_3.jpg)

### 命名管道
命名管道中的数据采用先进先出的传输方式，因此命名管道也被称为FIFO。在Linux中，用户可以使用mkfifo命令或者C语言中的mkfifo函数来创建命名管道，并手动指定使用该管道通信的进程。

### 两者异同
无论是哪种管道，单个管道只能实现单向的通信，通信的数据都是缓存在内存的内核空间中。

命名管道在Linux中以文件的形式存在，可被多对进程反复调用；而匿名管道只存在于内存中，不存于文件系统中，其生命周期跟随进程，进程结束，匿名管道就消失了。

和匿名管道相比，命名管道可以指定任意两个进程来通信，不要求这两个进程是、有父子关系或创建自同一祖先进程。

## 消息队列
消息队列是存储于内核空间的链表，链表中每一个元素都存储一条信息。进程可以通过消息队列增加新元素的方式来上传信息，也可以从队列中读取元素来下载信息。

和管道相比，消息队列的生命周期跟随内核，只要没有手动释放消息队列或者关闭操作系统，消息队列会一直存在；而且消息队列适合进程间的频繁通信，效率更高。

当然，消息队列也有其不足之处。首先消息队列的通信不一定及时。某个进程上传信息的行为并不会通知其他进程，其他进程要访问消息队列才能得知自己需要的信息是否存在；其次，消息队列中存储的每则信息都有长度限制，不允许过大的数据交互；最后，由于消息队列运行于内核空间，进程从中存取信息都会导致从内核空间到用户空间来回复制数据，这会带来一定的开销。

## 共享内存
在给每个进程分配各自虚拟内存空间时，各自都取出一段相同的虚拟地址，并映射到同一物理内存地址处，这一块内存称为共享内存，这块内存每个进程都可读写，进程可通过该块内存进行通信或数据交互。

## 信号量
当进程使用共享内存通信时，如果多个进程同一时间读写共享内存，可能会造成冲突。而信号量机制可以避免进程竞争共享内存，保证数据的正确性。另外，信号量机制本身也可以在进程间传递“某个共享资源能否被访问”的信息，也可用于进程阻塞与唤醒，也算作一种通信机制。

简单来说，信号量就是一个整型计数器，其初始值表示资源的数量。有两种原子操作可以改变信号量：

- P操作：首先将信号量减1。若运算后结果 < 0，说明资源已耗尽，进程需阻塞等待；若结果 >=0，则表明还有资源可使用，进程可正常继续执行。
- V操作：首先将信号量加1。若运算后结果 <= 0，说明当前还有阻塞等待该资源的进程，唤醒其中一个进程，让其访问资源；若结果 > 0，则说明没有阻塞等待的进程，无需额外操作。

每个进程在访问共享资源前，会执行P操作。访问资源后会执行V操作，两个操作成对出现。

## 信号
唯一一种异步通信机制，进程收到信号后需要立刻执行对应信号的默认操作或信号处理函数。

硬件或软件都可以给进程发送信号。来自硬件的信号，举个例子，键盘输入的Ctrl + Z会向进程发送SIGTSTP信号，令进程挂起。而来自软件的信号，如```kill -9```命令，会向进程发送SIGKILL信号，让进程立刻结束。

通过```kill -l```可以查看所有的信号，其中常见的有：

- 1号信号SIGHUP：当用户的Shell连接关闭时发出的信号，与该Shell相关的进程收到该信号后会被终止。
- 2号信号SIGINT：终止进程，对应的键盘输入是Ctrl + c。
- 3号信号SIGQUIT：终止进程，并将进程内存空间的数据保存到磁盘上。
- 8号信号SIGFPE：进程中发生浮点运算错误（例如除以0）时会收到的信号，同样会终止进程。
- 9号信号SIGKILL：直接强制终止进程，该信号无法被捕捉，因此该信号对应的默认操作无法被修改。
- 11号信号SIGSEGV：进程崩溃（例如指针越界或非法访问）时会收到的信号，同样会终止进程。

## Socket
Socket一般用于跨网络不同主机上进程的通信，也可以用于同主机下不同进程的通信。其主要有三种通信模型：TCP、UDP以及本地进程间通信模型。
<br/><br/>


# 参考信息
[进程、线程基础知识](https://xiaolincoding.com/os/4_process/process_base.html)

[进程控制以及相关原语的使用（创建，终止，阻塞，唤醒，切换）](https://blog.csdn.net/qq_61888137/article/details/133469291)

[Linux：用户态和内核态的区别？什么时候会从用户态切换到内核态？](https://blog.csdn.net/weixin_42423872/article/details/99997106)

[【Linux】进程间通信——管道（1w5字图文详解，附代码和运行动图）](https://blog.csdn.net/Eristic0618/article/details/141832652)