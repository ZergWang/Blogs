# 什么是进程
## 进程的构造
运行中的程序被称为“进程”（Process）。每个进程中都有一个称为进程控制块（process control block，PCB）的数据结构来描述进程。PCB中包括进程标识符（PID）、用户标识符（进程从属的用户）、进程优先级、进程当前状态、CPU寄存器数据等信息。

## 进程的状态
### 创建状态（New）
创建一个新的进程。进程一般由其他进程调用fork()函数创建，刚创建出的进程会被分配一个空白的PCB并填入相关信息（例如PID），新进程还会被分配虚拟内存空间。

### 运行状态（Running）
此时进程占据CPU，CPU在全力处理进程的指令。当CPU空闲时，操作系统会根据调度算法，从就绪队列中选择合适的进程转为运行状态，并令CPU处理该进程。

### 就绪状态（Ready）
可以运行，但由于CPU在处理别的进程而处于的等待状态。所有就绪状态的进程会以链表的形式组织在就绪队列中。处于创建状态的进程在其PCB以及虚拟内存空间准备完毕后，会进入就绪状态（被加入就绪队列中）；阻塞状态中的进程在结束其事件后（例如IO结束后），其他进程会发送信息将其“唤醒”（阻塞状态的进程不能自行唤醒）。然后阻塞状态的进程会从阻塞队列移动到就绪队列中。


### 阻塞状态（Blocked）
该进程本来正在运行，但由于某些事件（例如等待IO）而停止运行。此时操作系统会保存该进程在CPU中运行时的环境与数据（例如CPU寄存器中的数据），然后将该进程放入以链表的形式组织的阻塞队列中。

### 挂起状态（Suspend）
为了防止大量处于就绪或阻塞状态的进程占用物理内存，这些进程有可能会被从内存移动到硬盘中保存。此时这些进程进入挂起状态。因此挂起状态可分为阻塞挂起状态（进程在硬盘中等待事件处理）以及就绪挂起状态（进程保存在硬盘中，但只要进入内存，就可直接进入就绪队列）。

在Linux中，可通过ctrl + z或sleep()函数让进程挂起。

### 结束状态（Exit）
进程运行完成，或者出错时，会被操作系统作结束状态处理。

![](Linux进程管理_1.jpg)

## 进程与作业
作业的概念主要用在批处理系统中。作业（job）是用户需要计算机完成的某项任务，一项作业可能需要一个或多个进程来完成，但一个进程只能属于一个作业。

## 进程控制原语（Primitive）
进程控制原语是一种特殊的程序，用于控制及切换进程的状态，其执行具有原子性。

### 创建原语

### 终止原语

### 阻塞原语

### 唤醒原语

### 


<br/><br/>

# 进程与线程
## 为何需要线程
多进程并发执行多种指令时，进程切换的开销比较大，而且进程间通信较为复杂。如果让单个进程依次执行这多种指令，则无法实现并发，资源利用率低，如果有需要交互的指令，还会造成极高的延迟。

对此，可以在单个进程中创建多个线程，每个线程负责一种指令。线程间可以并发执行，而且线程切换和线程间通信效率极高。

## 什么是线程
正如上文介绍的，线程（thread）可以看作是一种更细粒度的进程，但线程从属于某个进程。单个进程下可创建多个线程，这些线程共享进程虚拟内存空间的资源。


## 
<br/><br/>


# 线程调度
当线程运行完毕，或者因为某些事件阻塞或出错时，操作系统会根据其调度算法从就绪队列中选择另一个线程进入运行状态，这一过程称为线程调度。

## 上下文切换

当调度的两个线程属于同一进程时，会发生线程的上下文切换。如果不属于，还会发生进程的上下文切换。
### 线程的上下文切换


### 进程的上下文切换
进程在CPU中运行时，依赖CPU寄存器（存储进程运行时需要的数据）和CPU程序计数器（存储CPU正在执行的指令位置或者即将执行的指令位置）中的数据，这两块数据统称为进程的上下文。当发生进程调度时（假设进程A被移出CPU，B被移入CPU），A的上下文数据会存储到其PCB中，然后CPU从B的PCB中加载其上下文。这一过程称为进程的上下文切换。

## 调度原则
如何选择下一个要运行的线程。不同的调度算法有不同的标准，但基本上需要考虑以下指标：

- CPU利用率：CPU非空闲时间占全部时间的比例。

- 系统吞吐量：即单位时间内CPU完成线程的数量。

- 等待时间：线程在就绪队列中的时间。

- 周转时间：线程的周转时间等于其运行时间、阻塞时间、等待时间的总和（也就是线程从创建到运行完毕的时间）。

- 响应时间：用户提交请求到系统第一次产生响应所花费的时间。对于交互式的线程，响应时间是衡量调度算法好坏的主要标准。

综上，好的调度算法，应该尽量提高CPU利用率和系统吞吐量，降低线程等待时间、周转时间以及响应时间。

## 调度算法
一般分为抢占式算法和非抢占式算法。前者只让线程在CPU中运行一定时段，时段结束后即使线程没运行完也会被移出，调度其他线程运行。后者则会让选中的线程一直运行，直到其阻塞、运行结束或出错，再调度其他线程运行。

### 先来先服务算法（First Come First Serve，FCFS）
非抢占式算法，调度时选择最早进入就绪队列的线程来运行。该算法不利于运行时间短的线程。试想，假设某个线程A运行时间很短，但它排在一个运行时间很长的线程B后面。则线程A的等待时间可能远远长于其运行时间。

### 最短作业优先算法（Shortest Job First，SJF）
非抢占式算法，调度时选择就绪队列中运行时间最短的线程来运行。

那么操作系统是如何得知每个线程的运行时间呢？实际上这个“运行时间”是操作系统根据过去同类型线程执行时间经过加权平均估算出来的。

SJF算法不利于运行时间长的线程，可能会导致其饥饿。

### 最短剩余时间优先算法（Shortest Remaining Time Next，SRTN）
可以看作是抢占式的SJF。当有新的线程加入就绪队列时，就将该新线程的运行时间与正在运行的线程的剩余运行时间进行比较，如果新线程运行时间更短，则进行调度。

### 时间片轮转算法（Round Robin，RR）
抢占式算法。每个线程只能在CPU中运行指定的时间片，时间片用完或者线程提前结束、出错或阻塞，则进行调度。

### 最高优先级算法（Highest Priority First，HPF）
该算法分为抢占式和非抢占式两种版本，但都是从就绪队列中选择优先级最高的线程来运行。线程的优先级在创建时会被确定。但在某些情况下该优先级也会变动（例如，线程在就绪队列中等待的时间越久，其优先级可能会被调高）。


### 多级反馈队列算法（Multilevel Feedback Queue）
抢占式算法。维护多个就绪队列，不同的就绪队列有不同的优先级。当调度时，先调度最高优先级队列中的线程。如果队列为空，则调度次优先级队列中的线程，以此类推。对于同一优先级的就绪队列，其中的线程按先来先服务的原则调度。


处于不同优先级队列的线程，调度时分配的时间片也不同。优先级越高的，时间片越短。当时间片用完时，线程还未执行完，则发生抢占，被抢占的线程会加入到低优先级的就绪队列中。

对于正在运行的线程，如果比其高优先级的队列中有新的线程，则发生抢占，被抢占的线程重新加入到其同一优先级的队列中。

![](Linux进程管理_2.jpg)




<br/><br/>

# 参考信息
[进程、线程基础知识](https://xiaolincoding.com/os/4_process/process_base.html)